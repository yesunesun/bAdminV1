DATABASE STRUCTURE:
======================================================================

TABLES AND COLUMNS:
----------------------------------------------------------------------
Schema: auth | Table: saml_providers
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: sso_provider_id      Type: uuid            Max Length: None Nullable: NO
Column: entity_id            Type: text            Max Length: None Nullable: NO
Column: metadata_xml         Type: text            Max Length: None Nullable: NO
Column: metadata_url         Type: text            Max Length: None Nullable: YES
Column: attribute_mapping    Type: jsonb           Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: name_id_format       Type: text            Max Length: None Nullable: YES

Schema: auth | Table: saml_relay_states
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: sso_provider_id      Type: uuid            Max Length: None Nullable: NO
Column: request_id           Type: text            Max Length: None Nullable: NO
Column: for_email            Type: text            Max Length: None Nullable: YES
Column: redirect_to          Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: flow_state_id        Type: uuid            Max Length: None Nullable: YES

Schema: auth | Table: audit_log_entries
----------------------------------------------------------------------
Column: instance_id          Type: uuid            Max Length: None Nullable: YES
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: payload              Type: json            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: ip_address           Type: character varying Max Length: 64 Nullable: NO

Schema: auth | Table: schema_migrations
----------------------------------------------------------------------
Column: version              Type: character varying Max Length: 255 Nullable: NO

Schema: auth | Table: sessions
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: factor_id            Type: uuid            Max Length: None Nullable: YES
Column: aal                  Type: USER-DEFINED    Max Length: None Nullable: YES
Column: not_after            Type: timestamp with time zone Max Length: None Nullable: YES
Column: refreshed_at         Type: timestamp without time zone Max Length: None Nullable: YES
Column: user_agent           Type: text            Max Length: None Nullable: YES
Column: ip                   Type: inet            Max Length: None Nullable: YES
Column: tag                  Type: text            Max Length: None Nullable: YES

Schema: auth | Table: refresh_tokens
----------------------------------------------------------------------
Column: instance_id          Type: uuid            Max Length: None Nullable: YES
Column: id                   Type: bigint          Max Length: None Nullable: NO
Column: token                Type: character varying Max Length: 255 Nullable: YES
Column: user_id              Type: character varying Max Length: 255 Nullable: YES
Column: revoked              Type: boolean         Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: parent               Type: character varying Max Length: 255 Nullable: YES
Column: session_id           Type: uuid            Max Length: None Nullable: YES

Schema: auth | Table: mfa_factors
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: friendly_name        Type: text            Max Length: None Nullable: YES
Column: factor_type          Type: USER-DEFINED    Max Length: None Nullable: NO
Column: status               Type: USER-DEFINED    Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: secret               Type: text            Max Length: None Nullable: YES
Column: phone                Type: text            Max Length: None Nullable: YES
Column: last_challenged_at   Type: timestamp with time zone Max Length: None Nullable: YES
Column: web_authn_credential Type: jsonb           Max Length: None Nullable: YES
Column: web_authn_aaguid     Type: uuid            Max Length: None Nullable: YES

Schema: auth | Table: one_time_tokens
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: token_type           Type: USER-DEFINED    Max Length: None Nullable: NO
Column: token_hash           Type: text            Max Length: None Nullable: NO
Column: relates_to           Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp without time zone Max Length: None Nullable: NO
Column: updated_at           Type: timestamp without time zone Max Length: None Nullable: NO

Schema: auth | Table: mfa_amr_claims
----------------------------------------------------------------------
Column: session_id           Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: authentication_method Type: text            Max Length: None Nullable: NO
Column: id                   Type: uuid            Max Length: None Nullable: NO

Schema: auth | Table: flow_state
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: YES
Column: auth_code            Type: text            Max Length: None Nullable: NO
Column: code_challenge_method Type: USER-DEFINED    Max Length: None Nullable: NO
Column: code_challenge       Type: text            Max Length: None Nullable: NO
Column: provider_type        Type: text            Max Length: None Nullable: NO
Column: provider_access_token Type: text            Max Length: None Nullable: YES
Column: provider_refresh_token Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: authentication_method Type: text            Max Length: None Nullable: NO
Column: auth_code_issued_at  Type: timestamp with time zone Max Length: None Nullable: YES

Schema: auth | Table: identities
----------------------------------------------------------------------
Column: provider_id          Type: text            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: identity_data        Type: jsonb           Max Length: None Nullable: NO
Column: provider             Type: text            Max Length: None Nullable: NO
Column: last_sign_in_at      Type: timestamp with time zone Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: email                Type: text            Max Length: None Nullable: YES
Column: id                   Type: uuid            Max Length: None Nullable: NO

Schema: auth | Table: instances
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: uuid                 Type: uuid            Max Length: None Nullable: YES
Column: raw_base_config      Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: auth | Table: mfa_challenges
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: factor_id            Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: verified_at          Type: timestamp with time zone Max Length: None Nullable: YES
Column: ip_address           Type: inet            Max Length: None Nullable: NO
Column: otp_code             Type: text            Max Length: None Nullable: YES
Column: web_authn_session_data Type: jsonb           Max Length: None Nullable: YES

Schema: auth | Table: sso_domains
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: sso_provider_id      Type: uuid            Max Length: None Nullable: NO
Column: domain               Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: auth | Table: sso_providers
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: resource_id          Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: auth | Table: users
----------------------------------------------------------------------
Column: instance_id          Type: uuid            Max Length: None Nullable: YES
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: aud                  Type: character varying Max Length: 255 Nullable: YES
Column: role                 Type: character varying Max Length: 255 Nullable: YES
Column: email                Type: character varying Max Length: 255 Nullable: YES
Column: encrypted_password   Type: character varying Max Length: 255 Nullable: YES
Column: email_confirmed_at   Type: timestamp with time zone Max Length: None Nullable: YES
Column: invited_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: confirmation_token   Type: character varying Max Length: 255 Nullable: YES
Column: confirmation_sent_at Type: timestamp with time zone Max Length: None Nullable: YES
Column: recovery_token       Type: character varying Max Length: 255 Nullable: YES
Column: recovery_sent_at     Type: timestamp with time zone Max Length: None Nullable: YES
Column: email_change_token_new Type: character varying Max Length: 255 Nullable: YES
Column: email_change         Type: character varying Max Length: 255 Nullable: YES
Column: email_change_sent_at Type: timestamp with time zone Max Length: None Nullable: YES
Column: last_sign_in_at      Type: timestamp with time zone Max Length: None Nullable: YES
Column: raw_app_meta_data    Type: jsonb           Max Length: None Nullable: YES
Column: raw_user_meta_data   Type: jsonb           Max Length: None Nullable: YES
Column: is_super_admin       Type: boolean         Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: phone                Type: text            Max Length: None Nullable: YES
Column: phone_confirmed_at   Type: timestamp with time zone Max Length: None Nullable: YES
Column: phone_change         Type: text            Max Length: None Nullable: YES
Column: phone_change_token   Type: character varying Max Length: 255 Nullable: YES
Column: phone_change_sent_at Type: timestamp with time zone Max Length: None Nullable: YES
Column: confirmed_at         Type: timestamp with time zone Max Length: None Nullable: YES
Column: email_change_token_current Type: character varying Max Length: 255 Nullable: YES
Column: email_change_confirm_status Type: smallint        Max Length: None Nullable: YES
Column: banned_until         Type: timestamp with time zone Max Length: None Nullable: YES
Column: reauthentication_token Type: character varying Max Length: 255 Nullable: YES
Column: reauthentication_sent_at Type: timestamp with time zone Max Length: None Nullable: YES
Column: is_sso_user          Type: boolean         Max Length: None Nullable: NO
Column: deleted_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: is_anonymous         Type: boolean         Max Length: None Nullable: NO

Schema: public | Table: admin_roles
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: role_type            Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: properties_temp
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: title                Type: text            Max Length: None Nullable: NO
Column: price                Type: numeric         Max Length: None Nullable: NO
Column: location             Type: text            Max Length: None Nullable: NO
Column: beds                 Type: integer         Max Length: None Nullable: NO
Column: baths                Type: integer         Max Length: None Nullable: NO
Column: sqft                 Type: integer         Max Length: None Nullable: NO
Column: type                 Type: text            Max Length: None Nullable: NO
Column: image                Type: text            Max Length: None Nullable: YES
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: address              Type: text            Max Length: None Nullable: YES
Column: city                 Type: text            Max Length: None Nullable: YES
Column: state                Type: text            Max Length: None Nullable: YES
Column: zip_code             Type: text            Max Length: None Nullable: YES
Column: bedrooms             Type: integer         Max Length: None Nullable: YES
Column: bathrooms            Type: numeric         Max Length: None Nullable: YES
Column: square_feet          Type: numeric         Max Length: None Nullable: YES
Column: description          Type: text            Max Length: None Nullable: YES

Schema: public | Table: admin_users
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: role_id              Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: properties
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: owner_id             Type: uuid            Max Length: None Nullable: NO
Column: title                Type: text            Max Length: None Nullable: NO
Column: description          Type: text            Max Length: None Nullable: YES
Column: price                Type: numeric         Max Length: None Nullable: NO
Column: bedrooms             Type: integer         Max Length: None Nullable: YES
Column: bathrooms            Type: numeric         Max Length: None Nullable: YES
Column: square_feet          Type: numeric         Max Length: None Nullable: YES
Column: address              Type: text            Max Length: None Nullable: YES
Column: city                 Type: text            Max Length: None Nullable: YES
Column: state                Type: text            Max Length: None Nullable: YES
Column: zip_code             Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: property_details     Type: jsonb           Max Length: None Nullable: YES
Column: status               Type: text            Max Length: None Nullable: YES
Column: tags                 Type: ARRAY           Max Length: None Nullable: YES

Schema: public | Table: property_visits
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: visited_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: visit_count          Type: integer         Max Length: None Nullable: YES
Column: visit_date           Type: timestamp with time zone Max Length: None Nullable: YES
Column: message              Type: text            Max Length: None Nullable: YES
Column: status               Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: confirmed_at         Type: timestamp with time zone Max Length: None Nullable: YES
Column: rejected_at          Type: timestamp with time zone Max Length: None Nullable: YES
Column: rejection_reason     Type: text            Max Length: None Nullable: YES

Schema: public | Table: property_likes
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: property_images
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: YES
Column: url                  Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: is_primary           Type: boolean         Max Length: None Nullable: YES
Column: display_order        Type: integer         Max Length: None Nullable: YES
Column: data_url             Type: text            Max Length: None Nullable: YES

Schema: public | Table: profiles
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: email                Type: text            Max Length: None Nullable: NO
Column: phone                Type: text            Max Length: None Nullable: YES
Column: role                 Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: NO

Schema: public | Table: property_coordinates
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: latitude             Type: numeric         Max Length: None Nullable: NO
Column: longitude            Type: numeric         Max Length: None Nullable: NO
Column: address              Type: text            Max Length: None Nullable: YES
Column: city                 Type: text            Max Length: None Nullable: YES
Column: state                Type: text            Max Length: None Nullable: YES
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: temp_property_listing
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: owner_id             Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: property_details     Type: jsonb           Max Length: None Nullable: NO
Column: status               Type: text            Max Length: None Nullable: YES
Column: last_active_step     Type: text            Max Length: None Nullable: YES
Column: flow_type            Type: text            Max Length: None Nullable: NO

Schema: public | Table: properties_v2_likes
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: v2_favorites
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: user_id              Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES

Schema: public | Table: properties_v2
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: owner_id             Type: uuid            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: updated_at           Type: timestamp with time zone Max Length: None Nullable: YES
Column: property_details     Type: jsonb           Max Length: None Nullable: YES
Column: status               Type: text            Max Length: None Nullable: YES

Schema: public | Table: owner_notifications
----------------------------------------------------------------------
Column: id                   Type: uuid            Max Length: None Nullable: NO
Column: owner_id             Type: uuid            Max Length: None Nullable: NO
Column: property_id          Type: uuid            Max Length: None Nullable: NO
Column: visit_id             Type: uuid            Max Length: None Nullable: YES
Column: title                Type: text            Max Length: None Nullable: NO
Column: message              Type: text            Max Length: None Nullable: NO
Column: is_read              Type: boolean         Max Length: None Nullable: NO
Column: notification_type    Type: text            Max Length: None Nullable: NO
Column: created_at           Type: timestamp with time zone Max Length: None Nullable: NO

FOREIGN KEY RELATIONSHIPS:
----------------------------------------------------------------------
From auth.identities Column 'user_id' -> auth.users Column 'id'
From auth.mfa_amr_claims Column 'session_id' -> auth.sessions Column 'id'
From auth.mfa_challenges Column 'factor_id' -> auth.mfa_factors Column 'id'
From auth.mfa_factors Column 'user_id' -> auth.users Column 'id'
From auth.one_time_tokens Column 'user_id' -> auth.users Column 'id'
From auth.refresh_tokens Column 'session_id' -> auth.sessions Column 'id'
From auth.saml_providers Column 'sso_provider_id' -> auth.sso_providers Column 'id'
From auth.saml_relay_states Column 'flow_state_id' -> auth.flow_state Column 'id'
From auth.saml_relay_states Column 'sso_provider_id' -> auth.sso_providers Column 'id'
From auth.sessions Column 'user_id' -> auth.users Column 'id'
From auth.sso_domains Column 'sso_provider_id' -> auth.sso_providers Column 'id'
From public.property_images Column 'property_id' -> public.properties Column 'id'
From public.properties Column 'owner_id' -> public.profiles Column 'id'
From public.admin_users Column 'role_id' -> public.admin_roles Column 'id'
From public.property_likes Column 'property_id' -> public.properties Column 'id'
From public.property_visits Column 'property_id' -> public.properties Column 'id'
From public.owner_notifications Column 'owner_id' -> public.profiles Column 'id'
From public.owner_notifications Column 'property_id' -> public.properties Column 'id'
From public.owner_notifications Column 'visit_id' -> public.property_visits Column 'id'
From public.properties_v2 Column 'owner_id' -> public.profiles Column 'id'
From public.properties_v2_likes Column 'property_id' -> public.properties_v2 Column 'id'
From public.temp_property_listing Column 'owner_id' -> public.profiles Column 'id'
From public.property_coordinates Column 'property_id' -> public.properties_v2 Column 'id'

ROW-LEVEL SECURITY POLICIES:
----------------------------------------------------------------------
Schema: public | Table: properties | Policy: Anyone can view properties
  Permissive: PERMISSIVE | Roles: ['public'] | Command: SELECT
  Qual: true | With Check: None

Schema: public | Table: properties | Policy: Users can insert their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = owner_id)

Schema: public | Table: properties | Policy: Users can update their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (auth.uid() = owner_id) | With Check: (auth.uid() = owner_id)

Schema: public | Table: properties | Policy: Users can delete their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: auth | Table: users | Policy: Allow password reset for admins
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (EXISTS ( SELECT 1
   FROM admin_users au
  WHERE (au.user_id = auth.uid()))) | With Check: (EXISTS ( SELECT 1
   FROM admin_users au
  WHERE (au.user_id = auth.uid())))

Schema: public | Table: property_visits | Policy: Users can view their own visits
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: property_visits | Policy: Users can add their own visits
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = user_id)

Schema: public | Table: property_visits | Policy: Users can update their own visits
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: v2_favorites | Policy: Users can manage their own favorites
  Permissive: PERMISSIVE | Roles: ['public'] | Command: ALL
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: properties_v2 | Policy: Allow video uploads for property owners and admins
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: ((auth.uid() = owner_id) OR (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text])))))) | With Check: ((auth.uid() = owner_id) OR (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text]))))))

Schema: public | Table: owner_notifications | Policy: Owners can view their own notifications
  Permissive: PERMISSIVE | Roles: ['public'] | Command: SELECT
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: public | Table: owner_notifications | Policy: Owners can update their own notifications
  Permissive: PERMISSIVE | Roles: ['public'] | Command: UPDATE
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: public | Table: owner_notifications | Policy: System can insert notifications
  Permissive: PERMISSIVE | Roles: ['public'] | Command: INSERT
  Qual: None | With Check: true

Schema: public | Table: property_coordinates | Policy: Anyone can view property coordinates
  Permissive: PERMISSIVE | Roles: ['public'] | Command: SELECT
  Qual: true | With Check: None

Schema: public | Table: property_coordinates | Policy: Property owners can insert coordinates
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (EXISTS ( SELECT 1
   FROM properties_v2
  WHERE ((properties_v2.id = property_coordinates.property_id) AND (properties_v2.owner_id = auth.uid()))))

Schema: public | Table: property_coordinates | Policy: Property owners can update coordinates
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (EXISTS ( SELECT 1
   FROM properties_v2
  WHERE ((properties_v2.id = property_coordinates.property_id) AND (properties_v2.owner_id = auth.uid())))) | With Check: (EXISTS ( SELECT 1
   FROM properties_v2
  WHERE ((properties_v2.id = property_coordinates.property_id) AND (properties_v2.owner_id = auth.uid()))))

Schema: public | Table: property_coordinates | Policy: Admins can manage all coordinates
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: ALL
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text]))))) | With Check: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text])))))

Schema: public | Table: admin_roles | Policy: admin_roles_policy
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: true | With Check: None

Schema: public | Table: admin_users | Policy: admin_users_policy
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: ((user_id = auth.uid()) OR (role_id IN ( SELECT admin_roles.id
   FROM admin_roles
  WHERE (admin_roles.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text]))))) | With Check: None

Schema: public | Table: profiles | Policy: profiles_read_policy
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: ((id = auth.uid()) OR (auth.uid() IN ( SELECT admin_users.user_id
   FROM admin_users))) | With Check: None

Schema: public | Table: profiles | Policy: profiles_update_policy
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: ((id = auth.uid()) OR (auth.uid() IN ( SELECT admin_users.user_id
   FROM admin_users))) | With Check: None

Schema: public | Table: properties | Policy: Admins can delete any property
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text]))))) | With Check: None

Schema: public | Table: properties | Policy: Property moderators can view all properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = 'property_moderator'::text)))) | With Check: None

Schema: public | Table: properties_v2 | Policy: Anyone can view properties
  Permissive: PERMISSIVE | Roles: ['public'] | Command: SELECT
  Qual: true | With Check: None

Schema: public | Table: properties_v2 | Policy: Users can insert their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = owner_id)

Schema: public | Table: properties_v2 | Policy: Users can update their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (auth.uid() = owner_id) | With Check: (auth.uid() = owner_id)

Schema: public | Table: properties_v2 | Policy: Users can delete their own properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: public | Table: properties_v2 | Policy: Property moderators can manage all properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: ALL
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = 'property_moderator'::text)))) | With Check: None

Schema: public | Table: temp_property_listing | Policy: Users can view their own temporary listings
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: public | Table: temp_property_listing | Policy: Users can insert their own temporary listings
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = owner_id)

Schema: public | Table: temp_property_listing | Policy: Users can update their own temporary listings
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: UPDATE
  Qual: (auth.uid() = owner_id) | With Check: (auth.uid() = owner_id)

Schema: public | Table: profiles | Policy: Allow admins to view all profiles
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text]))))) | With Check: None

Schema: public | Table: temp_property_listing | Policy: Users can delete their own temporary listings
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (auth.uid() = owner_id) | With Check: None

Schema: public | Table: temp_property_listing | Policy: Property moderators can view all temporary listings
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = 'property_moderator'::text)))) | With Check: None

Schema: public | Table: profiles | Policy: Property moderators can create profiles
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = 'property_moderator'::text))))

Schema: public | Table: profiles | Policy: profiles_insert_policy
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: ((auth.uid() = id) OR (auth.uid() IN ( SELECT au.user_id
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text])))))

Schema: public | Table: properties_v2 | Policy: Admins can delete any property
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (EXISTS ( SELECT 1
   FROM (admin_users au
     JOIN admin_roles ar ON ((au.role_id = ar.id)))
  WHERE ((au.user_id = auth.uid()) AND (ar.role_type = ANY (ARRAY['admin'::text, 'super_admin'::text, 'property_moderator'::text]))))) | With Check: None

Schema: public | Table: property_images | Policy: Anyone can view property images
  Permissive: PERMISSIVE | Roles: ['public'] | Command: SELECT
  Qual: true | With Check: None

Schema: public | Table: property_images | Policy: Anyone can insert property images
  Permissive: PERMISSIVE | Roles: ['public'] | Command: INSERT
  Qual: None | With Check: true

Schema: public | Table: property_images | Policy: Anyone can update property images
  Permissive: PERMISSIVE | Roles: ['public'] | Command: UPDATE
  Qual: true | With Check: None

Schema: public | Table: property_images | Policy: Anyone can delete property images
  Permissive: PERMISSIVE | Roles: ['public'] | Command: DELETE
  Qual: true | With Check: None

Schema: public | Table: property_likes | Policy: Users can view their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: property_likes | Policy: Users can add their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = user_id)

Schema: public | Table: property_likes | Policy: Users can remove their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: property_likes | Policy: Property owners can see who liked their properties
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (EXISTS ( SELECT 1
   FROM properties
  WHERE ((properties.id = property_likes.property_id) AND (properties.owner_id = auth.uid())))) | With Check: None

Schema: public | Table: property_likes | Policy: Admins can view all likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (EXISTS ( SELECT 1
   FROM admin_users
  WHERE (admin_users.user_id = auth.uid()))) | With Check: None

Schema: public | Table: properties_v2_likes | Policy: Users can view their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: SELECT
  Qual: (auth.uid() = user_id) | With Check: None

Schema: public | Table: properties_v2_likes | Policy: Users can add their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: INSERT
  Qual: None | With Check: (auth.uid() = user_id)

Schema: public | Table: properties_v2_likes | Policy: Users can delete their own likes
  Permissive: PERMISSIVE | Roles: ['authenticated'] | Command: DELETE
  Qual: (auth.uid() = user_id) | With Check: None


STORED PROCEDURES / USER-DEFINED FUNCTIONS:
----------------------------------------------------------------------
Schema: public | Name: update_properties_v2_updated_at | Type: FUNCTION
  Returns: trigger | Specific Name: update_properties_v2_updated_at_160943
  Definition: 
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;


Schema: public | Name: extract_land_area_unit | Type: FUNCTION
  Returns: text | Specific Name: extract_land_area_unit_198683
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'land_sale_basic_details'->>'areaUnit',
        property_details->'steps'->'land_basic_details'->>'areaUnit',
        property_details->'steps'->'property_details'->>'areaUnit',
        property_details->'basicDetails'->>'areaUnit',
        property_details->'flow'->>'areaUnit',
        property_details->>'areaUnit',
        'sq_ft'
    );
END;


Schema: public | Name: extract_land_flow_type | Type: FUNCTION
  Returns: text | Specific Name: extract_land_flow_type_198685
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'flow'->>'flowType',
        property_details->>'flowType',
        property_details->>'flow_type',
        property_details->'meta'->>'flow_type',
        'land_sale'
    );
END;


Schema: public | Name: initialize_property_flow | Type: FUNCTION
  Returns: uuid | Specific Name: initialize_property_flow_179601
  Definition: 
DECLARE
    v_id UUID;
    v_property_details JSONB;
BEGIN
    -- Initialize property details with default template structure
    -- This ensures all new listings have consistent structure
    v_property_details = jsonb_build_object(
        'meta', jsonb_build_object(
            '_version', 'v3',
            'created_at', NOW(),
            'updated_at', NOW(),
            'status', 'draft'
        ),
        'flow', jsonb_build_object(
            'flowType', p_flow_type
        ),
        'steps', jsonb_build_object(),
        'media', jsonb_build_object(
            'photos', jsonb_build_object('images', '[]'::jsonb),
            'videos', jsonb_build_object('urls', '[]'::jsonb)
        )
    );

    -- If initial data is provided, merge it with default structure
    IF p_initial_data IS NOT NULL THEN
        v_property_details = v_property_details || p_initial_data;
    END IF;

    -- Insert the new temporary listing
    INSERT INTO public.temp_property_listing (
        owner_id,
        property_details,
        flow_type,
        last_active_step
    ) VALUES (
        p_owner_id,
        v_property_details,
        p_flow_type,
        'property_selection' -- Default first step
    )
    RETURNING id INTO v_id;

    RETURN v_id;
END;


Schema: public | Name: update_property_flow | Type: FUNCTION
  Returns: jsonb | Specific Name: update_property_flow_179602
  Definition: 
DECLARE
    v_existing_data JSONB;
    v_merged_data JSONB;
    v_result JSONB;
BEGIN
    -- Get existing property details
    SELECT property_details INTO v_existing_data
    FROM public.temp_property_listing
    WHERE id = p_flow_id AND owner_id = p_owner_id;

    IF v_existing_data IS NULL THEN
        RAISE EXCEPTION 'Temporary listing not found or access denied';
    END IF;

    -- Merge existing data with new data
    -- For nested JSON fields, this keeps existing fields and adds/updates new ones
    v_merged_data = v_existing_data;
    
    -- Update steps data specifically
    IF p_property_details ? 'steps' THEN
        v_merged_data = jsonb_set(
            v_merged_data,
            '{steps}',
            COALESCE(v_merged_data -> 'steps', '{}'::jsonb) || (p_property_details -> 'steps')
        );
    END IF;
    
    -- Update other top-level keys
    v_merged_data = v_merged_data || p_property_details;
    
    -- Always update the meta.updated_at timestamp
    v_merged_data = jsonb_set(
        v_merged_data,
        '{meta,updated_at}',
        to_jsonb(NOW())
    );

    -- Update the database
    UPDATE public.temp_property_listing
    SET 
        property_details = v_merged_data,
        updated_at = NOW(),
        last_active_step = COALESCE(p_current_step, last_active_step)
    WHERE id = p_flow_id AND owner_id = p_owner_id
    RETURNING property_details INTO v_result;

    RETURN v_result;
END;


Schema: public | Name: handle_new_admin_user | Type: FUNCTION
  Returns: trigger | Specific Name: handle_new_admin_user_60640
  Definition: 
BEGIN
  INSERT INTO public.admin_users (user_id, email, is_active, registration_date)
  VALUES (NEW.id, NEW.email, false, CURRENT_TIMESTAMP);
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RETURN NEW;
END;


Schema: public | Name: get_user_emails_by_ids | Type: FUNCTION
  Returns: record | Specific Name: get_user_emails_by_ids_80682
  Definition: 
BEGIN
  RETURN QUERY
  SELECT u.id, u.email
  FROM auth.users u
  WHERE u.id = ANY(user_ids);
END;


Schema: public | Name: admin_delete_property | Type: FUNCTION
  Returns: boolean | Specific Name: admin_delete_property_135334
  Definition: 
DECLARE
    success BOOLEAN;
BEGIN
    -- Delete property images first
    DELETE FROM public.property_images 
    WHERE property_id = property_id_param;
    
    -- Delete property visits
    DELETE FROM public.property_visits 
    WHERE property_id = property_id_param;
    
    -- Delete property likes
    DELETE FROM public.property_likes 
    WHERE property_id = property_id_param;
    
    -- Delete property notifications
    DELETE FROM public.owner_notifications 
    WHERE property_id = property_id_param;
    
    -- Finally delete the property
    DELETE FROM public.properties 
    WHERE id = property_id_param;
    
    GET DIAGNOSTICS success = ROW_COUNT;
    RETURN success > 0;
END;


Schema: public | Name: get_property_flow | Type: FUNCTION
  Returns: jsonb | Specific Name: get_property_flow_179603
  Definition: 
DECLARE
    v_result JSONB;
BEGIN
    SELECT jsonb_build_object(
        'id', id,
        'owner_id', owner_id,
        'created_at', created_at,
        'updated_at', updated_at,
        'property_details', property_details,
        'status', status,
        'last_active_step', last_active_step,
        'flow_type', flow_type
    ) INTO v_result
    FROM public.temp_property_listing
    WHERE id = p_flow_id AND owner_id = p_owner_id;

    RETURN v_result;
END;


Schema: public | Name: finalize_property_flow | Type: FUNCTION
  Returns: jsonb | Specific Name: finalize_property_flow_179604
  Definition: 
DECLARE
    v_property_details JSONB;
    v_flow_type TEXT;
    v_permanent_id UUID;
    v_result JSONB;
BEGIN
    -- Get the temporary listing data
    SELECT property_details, flow_type INTO v_property_details, v_flow_type
    FROM public.temp_property_listing
    WHERE id = p_flow_id AND owner_id = p_owner_id;

    IF v_property_details IS NULL THEN
        RAISE EXCEPTION 'Temporary listing not found or access denied';
    END IF;

    -- Insert into permanent table (properties_v2)
    INSERT INTO public.properties_v2 (
        owner_id,
        property_details,
        status
    ) VALUES (
        p_owner_id,
        v_property_details,
        'published'
    )
    RETURNING id INTO v_permanent_id;
    
    -- Update the temporary listing status to 'complete'
    UPDATE public.temp_property_listing
    SET status = 'complete'
    WHERE id = p_flow_id AND owner_id = p_owner_id;
    
    -- Return the result with both IDs
    v_result = jsonb_build_object(
        'flow_id', p_flow_id,
        'property_id', v_permanent_id,
        'status', 'complete'
    );
    
    RETURN v_result;
END;


Schema: public | Name: cleanup_abandoned_property_flows | Type: FUNCTION
  Returns: integer | Specific Name: cleanup_abandoned_property_flows_179605
  Definition: 
DECLARE
    v_count INTEGER;
BEGIN
    DELETE FROM public.temp_property_listing
    WHERE status = 'draft' AND updated_at < (NOW() - INTERVAL '30 days')
    RETURNING COUNT(*) INTO v_count;
    
    RETURN v_count;
END;


Schema: public | Name: create_visit_notification | Type: FUNCTION
  Returns: trigger | Specific Name: create_visit_notification_128070
  Definition: 
DECLARE
    property_title TEXT;
    property_owner_id UUID;
BEGIN
    -- Get property title and owner_id
    SELECT properties.title, properties.owner_id INTO property_title, property_owner_id
    FROM public.properties
    WHERE id = NEW.property_id;
    
    -- Insert notification for property owner
    INSERT INTO public.owner_notifications (
        owner_id,
        property_id,
        visit_id,
        title,
        message,
        notification_type
    ) VALUES (
        property_owner_id,
        NEW.property_id,
        NEW.id,
        'New Visit Request',
        'Someone has requested to visit your property: ' || property_title,
        'visit_request'
    );
    
    RETURN NEW;
END;


Schema: public | Name: create_profile_for_new_user | Type: FUNCTION
  Returns: trigger | Specific Name: create_profile_for_new_user_133056
  Definition: 
BEGIN
  INSERT INTO public.profiles (id, email, role, created_at, updated_at)
  VALUES (NEW.id, NEW.email, 'property_owner', NOW(), NOW())
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
END;


Schema: public | Name: update_property_title | Type: FUNCTION
  Returns: jsonb | Specific Name: update_property_title_184224
  Definition: 
DECLARE
  v_user_id uuid;
  v_is_admin boolean;
  v_property_owner uuid;
  v_current_details jsonb;
  v_updated_details jsonb;
  v_result jsonb;
BEGIN
  -- Get current user
  v_user_id := auth.uid();
  
  IF v_user_id IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'User not authenticated');
  END IF;
  
  -- Check if user is admin
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = v_user_id 
    AND ar.role_type IN ('admin', 'super_admin', 'property_moderator')
  ) INTO v_is_admin;
  
  -- Get property owner and current details
  SELECT owner_id, property_details 
  INTO v_property_owner, v_current_details
  FROM properties_v2 
  WHERE id = property_id_param;
  
  IF v_property_owner IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Property not found');
  END IF;
  
  -- Check permissions
  IF v_user_id != v_property_owner AND NOT v_is_admin THEN
    RETURN jsonb_build_object('success', false, 'error', 'Permission denied');
  END IF;
  
  -- Update the title in property_details
  v_updated_details := jsonb_set(
    COALESCE(v_current_details, '{}'::jsonb),
    '{flow,title}',
    to_jsonb(new_title_param),
    true
  );
  
  -- Update the database
  UPDATE properties_v2 
  SET 
    property_details = v_updated_details,
    updated_at = NOW()
  WHERE id = property_id_param;
  
  -- Return success
  RETURN jsonb_build_object(
    'success', true, 
    'property_id', property_id_param,
    'new_title', new_title_param,
    'updated_at', NOW()
  );
  
EXCEPTION
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'success', false, 
      'error', SQLERRM,
      'sqlstate', SQLSTATE
    );
END;


Schema: public | Name: extract_residential_latitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_residential_latitude_207320
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'res_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_flat_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_pg_location'->>'latitude'),
       safe_numeric(property_details->'location'->>'latitude'),
       safe_numeric(property_details->'coordinates'->>'lat'),
       safe_numeric(property_details->'coordinates'->>'latitude'),
       safe_numeric(property_details->>'latitude')
   );
END;


Schema: public | Name: extract_residential_longitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_residential_longitude_207321
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'res_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_flat_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_pg_location'->>'longitude'),
       safe_numeric(property_details->'location'->>'longitude'),
       safe_numeric(property_details->'coordinates'->>'lng'),
       safe_numeric(property_details->'coordinates'->>'longitude'),
       safe_numeric(property_details->>'longitude')
   );
END;


Schema: public | Name: search_residential_properties | Type: FUNCTION
  Returns: record | Specific Name: search_residential_properties_207322
  Definition: 
DECLARE
   v_total_count BIGINT;
BEGIN
   -- Validate parameters
   IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 1000 THEN
       p_limit := 50;
   END IF;
   
   IF p_offset IS NULL OR p_offset < 0 THEN
       p_offset := 0;
   END IF;

   -- Get total count using helper functions
   SELECT COUNT(*) INTO v_total_count
   FROM properties_v2 p
   WHERE p.status IS DISTINCT FROM 'deleted'
     AND extract_residential_flow_type(p.property_details) LIKE 'residential_%'
     AND matches_residential_subtype(p.property_details, p_subtype)
     AND (p_property_subtype IS NULL OR 
          extract_residential_property_type(p.property_details) ILIKE p_property_subtype)
     AND (p_search_query IS NULL OR 
          extract_residential_title(p.property_details) ILIKE '%' || p_search_query || '%')
     AND (p_city IS NULL OR 
          extract_residential_city(p.property_details) ILIKE '%' || p_city || '%')
     AND (p_state IS NULL OR 
          extract_residential_state(p.property_details) ILIKE '%' || p_state || '%')
     AND (p_min_price IS NULL OR 
          extract_residential_price(p.property_details) >= p_min_price)
     AND (p_max_price IS NULL OR 
          extract_residential_price(p.property_details) <= p_max_price)
     AND (p_bedrooms IS NULL OR 
          extract_residential_bedrooms(p.property_details) = p_bedrooms)
     AND (p_bathrooms IS NULL OR 
          extract_residential_bathrooms(p.property_details) >= p_bathrooms)
     AND (p_area_min IS NULL OR 
          extract_residential_area(p.property_details) >= p_area_min)
     AND (p_area_max IS NULL OR 
          extract_residential_area(p.property_details) <= p_area_max);

   -- Return results using helper functions (NOW INCLUDING COORDINATES)
   RETURN QUERY
   SELECT 
       -- MANDATORY CORE (8 fields)
       p.id,
       p.owner_id,
       p.created_at,
       p.updated_at,
       'residential'::TEXT as property_type,
       extract_residential_flow_type(p.property_details)::TEXT as flow_type,
       flow_type_to_subtype(extract_residential_flow_type(p.property_details))::TEXT as subtype,
       v_total_count as total_count,
       
       -- COMMON FIELDS (7 fields) - Using helper functions
       extract_residential_title(p.property_details)::TEXT as title,
       extract_residential_price(p.property_details) as price,
       extract_residential_city(p.property_details)::TEXT as city,
       extract_residential_state(p.property_details)::TEXT as state,
       extract_residential_area(p.property_details) as area,
       prof.email::TEXT as owner_email,
       COALESCE(p.status, 'active')::TEXT as status,
       
       -- TYPE-SPECIFIC FIELDS (4 fields) - Using helper functions
       extract_residential_bedrooms(p.property_details) as bedrooms,
       extract_residential_bathrooms(p.property_details) as bathrooms,
       'sq_ft'::TEXT as area_unit,
       NULL::TEXT as land_type,
       
       -- IMAGE FIELD
       extract_residential_primary_image(p.property_details)::TEXT as primary_image,
       
       -- COORDINATE FIELDS (NEW)
       extract_residential_latitude(p.property_details) as latitude,
       extract_residential_longitude(p.property_details) as longitude
       
   FROM properties_v2 p
   LEFT JOIN profiles prof ON p.owner_id = prof.id
   WHERE p.status IS DISTINCT FROM 'deleted'
     AND extract_residential_flow_type(p.property_details) LIKE 'residential_%'
     AND matches_residential_subtype(p.property_details, p_subtype)
     AND (p_property_subtype IS NULL OR 
          extract_residential_property_type(p.property_details) ILIKE p_property_subtype)
     AND (p_search_query IS NULL OR 
          extract_residential_title(p.property_details) ILIKE '%' || p_search_query || '%')
     AND (p_city IS NULL OR 
          extract_residential_city(p.property_details) ILIKE '%' || p_city || '%')
     AND (p_state IS NULL OR 
          extract_residential_state(p.property_details) ILIKE '%' || p_state || '%')
     AND (p_min_price IS NULL OR 
          extract_residential_price(p.property_details) >= p_min_price)
     AND (p_max_price IS NULL OR 
          extract_residential_price(p.property_details) <= p_max_price)
     AND (p_bedrooms IS NULL OR 
          extract_residential_bedrooms(p.property_details) = p_bedrooms)
     AND (p_bathrooms IS NULL OR 
          extract_residential_bathrooms(p.property_details) >= p_bathrooms)
     AND (p_area_min IS NULL OR 
          extract_residential_area(p.property_details) >= p_area_min)
     AND (p_area_max IS NULL OR 
          extract_residential_area(p.property_details) <= p_area_max)
   ORDER BY p.created_at DESC
   LIMIT p_limit OFFSET p_offset;
   
END;


Schema: public | Name: update_property_coordinates_updated_at | Type: FUNCTION
  Returns: trigger | Specific Name: update_property_coordinates_updated_at_186886
  Definition: 
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;


Schema: public | Name: get_all_auth_users | Type: FUNCTION
  Returns: json | Specific Name: get_all_auth_users_78194
  Definition: 
BEGIN
  RETURN QUERY SELECT 
    json_build_object(
      'id', u.id,
      'email', u.email,
      'created_at', u.created_at,
      'last_sign_in_at', u.last_sign_in_at,
      'role', COALESCE(p.role, u.raw_user_meta_data->>'role', 'user'),
      'phone', COALESCE(p.phone, u.phone),
      'invited_at', u.invited_at,
      'banned_until', u.banned_until,
      'has_profile', (p.id IS NOT NULL)
    )
  FROM auth.users u
  LEFT JOIN public.profiles p ON u.id = p.id
  ORDER BY u.created_at DESC;
END;


Schema: public | Name: extract_land_price | Type: FUNCTION
  Returns: numeric | Specific Name: extract_land_price_198678
  Definition: 
BEGIN
    RETURN COALESCE(
        safe_numeric(property_details->'flow'->>'price'),
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'price'),
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'expectedPrice'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'price'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'expectedPrice'),
        safe_numeric(property_details->'steps'->'property_details'->>'price'),
        safe_numeric(property_details->'steps'->'property_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'sale_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'sale_details'->>'expectedPrice'),
        safe_numeric(property_details->'sale'->>'salePrice'),
        safe_numeric(property_details->'sale'->>'expectedPrice'),
        safe_numeric(property_details->>'price'),
        safe_numeric(property_details->>'salePrice'),
        safe_numeric(property_details->>'expectedPrice')
    );
END;


Schema: public | Name: extract_land_title | Type: FUNCTION
  Returns: text | Specific Name: extract_land_title_198679
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'flow'->>'title',
        property_details->'steps'->'land_sale_basic_details'->>'title',
        property_details->'steps'->'land_basic_details'->>'title',
        property_details->'steps'->'property_details'->>'title',
        property_details->'basicDetails'->>'title',
        'Land Property'
    );
END;


Schema: public | Name: extract_land_city | Type: FUNCTION
  Returns: text | Specific Name: extract_land_city_198680
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'land_sale_location'->>'city',
        property_details->'steps'->'land_location'->>'city',
        property_details->'steps'->'location_details'->>'city',
        property_details->'location'->>'city',
        property_details->'flow'->>'city',
        property_details->>'city'
    );
END;


Schema: public | Name: extract_land_state | Type: FUNCTION
  Returns: text | Specific Name: extract_land_state_198681
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'land_sale_location'->>'state',
        property_details->'steps'->'land_location'->>'state',
        property_details->'steps'->'location_details'->>'state',
        property_details->'location'->>'state',
        property_details->'flow'->>'state',
        property_details->>'state'
    );
END;


Schema: public | Name: get_users_by_ids | Type: FUNCTION
  Returns: record | Specific Name: get_users_by_ids_80724
  Definition: 
BEGIN
  RETURN QUERY
  SELECT u.id, u.email
  FROM auth.users u
  WHERE u.id = ANY(user_ids);
END;


Schema: public | Name: extract_land_area | Type: FUNCTION
  Returns: numeric | Specific Name: extract_land_area_198682
  Definition: 
BEGIN
    RETURN COALESCE(
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'land_sale_basic_details'->>'landArea'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'land_basic_details'->>'landArea'),
        safe_numeric(property_details->'steps'->'property_details'->>'area'),
        safe_numeric(property_details->'steps'->'property_details'->>'totalArea'),
        safe_numeric(property_details->'basicDetails'->>'area'),
        safe_numeric(property_details->'basicDetails'->>'totalArea'),
        safe_numeric(property_details->'flow'->>'area'),
        safe_numeric(property_details->>'area'),
        safe_numeric(property_details->>'totalArea'),
        safe_numeric(property_details->>'landArea')
    );
END;


Schema: public | Name: extract_land_type | Type: FUNCTION
  Returns: text | Specific Name: extract_land_type_198684
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'land_sale_basic_details'->>'landType',
        property_details->'steps'->'land_basic_details'->>'landType',
        property_details->'steps'->'land_sale_basic_details'->>'propertyType',
        property_details->'steps'->'land_basic_details'->>'propertyType',
        property_details->'steps'->'property_details'->>'landType',
        property_details->'steps'->'property_details'->>'propertyType',
        property_details->'basicDetails'->>'landType',
        property_details->'basicDetails'->>'propertyType',
        property_details->'flow'->>'landType',
        property_details->'flow'->>'propertyType',
        property_details->>'landType',
        property_details->>'propertyType',
        'agricultural'
    );
END;


Schema: public | Name: extract_land_property_subtype | Type: FUNCTION
  Returns: text | Specific Name: extract_land_property_subtype_198686
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'land_sale_basic_details'->>'propertySubtype',
        property_details->'steps'->'land_basic_details'->>'propertySubtype',
        property_details->'steps'->'property_details'->>'propertySubtype',
        property_details->'basicDetails'->>'propertySubtype'
    );
END;


Schema: public | Name: confirm_visit_request | Type: FUNCTION
  Returns: jsonb | Specific Name: confirm_visit_request_128114
  Definition: 
DECLARE
    visit_record RECORD;
    property_title TEXT;
    user_email TEXT;
    result JSONB;
BEGIN
    -- Get visit information
    SELECT v.*, p.title INTO visit_record
    FROM public.property_visits v
    JOIN public.properties p ON v.property_id = p.id
    WHERE v.id = visit_id;
    
    -- If visit not found or already confirmed/rejected
    IF visit_record IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit request not found');
    END IF;
    
    IF visit_record.confirmed_at IS NOT NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit already confirmed');
    END IF;
    
    IF visit_record.rejected_at IS NOT NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit already rejected');
    END IF;
    
    -- Get user email
    SELECT email INTO user_email
    FROM public.profiles
    WHERE id = visit_record.user_id;
    
    -- Update visit to confirmed
    UPDATE public.property_visits
    SET 
        confirmed_at = NOW(),
        status = 'confirmed'
    WHERE id = visit_id;
    
    -- Create notification for visitor
    INSERT INTO public.owner_notifications (
        owner_id,
        property_id,
        visit_id,
        title,
        message,
        notification_type
    ) VALUES (
        visit_record.user_id,
        visit_record.property_id,
        visit_record.id,
        'Visit Request Confirmed',
        'Your visit request for ' || visit_record.title || ' has been confirmed for ' || 
        to_char(visit_record.visit_date, 'DD-MM-YYYY'),
        'visit_confirmed'
    );
    
    RETURN jsonb_build_object(
        'success', true, 
        'message', 'Visit confirmed successfully',
        'visit_id', visit_id
    );
END;


Schema: public | Name: get_property_type_stats | Type: FUNCTION
  Returns: record | Specific Name: get_property_type_stats_188510
  Definition: 
BEGIN
    RETURN QUERY
    WITH property_flows AS (
        SELECT 
            CASE 
                WHEN COALESCE(
                    property_details->'flow'->>'flowType',
                    property_details->>'flowType',
                    'residential_rent'
                ) LIKE 'residential_%' THEN 'residential'
                WHEN COALESCE(
                    property_details->'flow'->>'flowType',
                    property_details->>'flowType',
                    'residential_rent'
                ) LIKE 'commercial_%' THEN 'commercial'
                WHEN COALESCE(
                    property_details->'flow'->>'flowType',
                    property_details->>'flowType',
                    'residential_rent'
                ) LIKE 'land_%' THEN 'land'
                ELSE 'residential'
            END as prop_type,
            COALESCE(
                property_details->'flow'->>'flowType',
                property_details->>'flowType',
                'residential_rent'
            ) as flow_type_val
        FROM properties_v2
        WHERE status IS DISTINCT FROM 'deleted'
    )
    SELECT 
        prop_type as property_type,
        flow_type_val as flow_type,
        COUNT(*) as count
    FROM property_flows
    GROUP BY prop_type, flow_type_val
    ORDER BY prop_type, flow_type_val;
END;


Schema: public | Name: extract_and_upsert_property_coordinates | Type: FUNCTION
  Returns: jsonb | Specific Name: extract_and_upsert_property_coordinates_186909
  Definition: 
DECLARE
    v_property_record RECORD;
    v_property_details JSONB;
    v_step_key TEXT;
    v_step_data JSONB;
    v_latitude DECIMAL(10, 8);
    v_longitude DECIMAL(11, 8);
    v_address TEXT;
    v_city TEXT;
    v_state TEXT;
    v_result JSONB;
BEGIN
    -- Get the property record
    SELECT * INTO v_property_record
    FROM public.properties_v2
    WHERE id = p_property_id;
    
    IF v_property_record IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Property not found'
        );
    END IF;
    
    -- Parse property_details
    v_property_details := v_property_record.property_details;
    
    -- Extract coordinates from steps using a cursor approach
    IF v_property_details ? 'steps' THEN
        -- Loop through each step to find location data
        FOR v_step_key IN SELECT jsonb_object_keys(v_property_details->'steps')
        LOOP
            v_step_data := v_property_details->'steps'->v_step_key;
            
            -- Check if this step contains location data
            IF v_step_key LIKE '%location%' AND jsonb_typeof(v_step_data) = 'object' THEN
                -- Check for coordinates in this step
                IF v_step_data ? 'latitude' AND v_step_data ? 'longitude' THEN
                    BEGIN
                        v_latitude := (v_step_data->>'latitude')::DECIMAL(10, 8);
                        v_longitude := (v_step_data->>'longitude')::DECIMAL(11, 8);
                        v_address := v_step_data->>'address';
                        v_city := v_step_data->>'city';
                        v_state := v_step_data->>'state';
                        EXIT; -- Found coordinates, exit loop
                    EXCEPTION
                        WHEN OTHERS THEN
                            -- Invalid coordinate format, continue to next step
                            CONTINUE;
                    END;
                END IF;
            END IF;
        END LOOP;
    END IF;
    
    -- If no coordinates found in steps, try other locations
    IF v_latitude IS NULL OR v_longitude IS NULL THEN
        -- Try coordinates field
        IF v_property_details ? 'coordinates' THEN
            BEGIN
                IF v_property_details->'coordinates' ? 'lat' AND v_property_details->'coordinates' ? 'lng' THEN
                    v_latitude := (v_property_details->'coordinates'->>'lat')::DECIMAL(10, 8);
                    v_longitude := (v_property_details->'coordinates'->>'lng')::DECIMAL(11, 8);
                ELSIF v_property_details->'coordinates' ? 'latitude' AND v_property_details->'coordinates' ? 'longitude' THEN
                    v_latitude := (v_property_details->'coordinates'->>'latitude')::DECIMAL(10, 8);
                    v_longitude := (v_property_details->'coordinates'->>'longitude')::DECIMAL(11, 8);
                END IF;
            EXCEPTION
                WHEN OTHERS THEN
                    -- Invalid coordinate format, continue
                    NULL;
            END;
        END IF;
    END IF;
    
    -- Try direct lat/lng fields if still no coordinates
    IF v_latitude IS NULL OR v_longitude IS NULL THEN
        BEGIN
            IF v_property_details ? 'lat' AND v_property_details ? 'lng' THEN
                v_latitude := (v_property_details->>'lat')::DECIMAL(10, 8);
                v_longitude := (v_property_details->>'lng')::DECIMAL(11, 8);
            ELSIF v_property_details ? 'latitude' AND v_property_details ? 'longitude' THEN
                v_latitude := (v_property_details->>'latitude')::DECIMAL(10, 8);
                v_longitude := (v_property_details->>'longitude')::DECIMAL(11, 8);
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                -- Invalid coordinate format
                NULL;
        END;
    END IF;
    
    -- If still no coordinates, return error
    IF v_latitude IS NULL OR v_longitude IS NULL THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'No valid coordinates found in property data'
        );
    END IF;
    
    -- Validate coordinate ranges
    IF v_latitude < -90 OR v_latitude > 90 OR v_longitude < -180 OR v_longitude > 180 THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'Invalid coordinate values (latitude: ' || v_latitude || ', longitude: ' || v_longitude || ')'
        );
    END IF;
    
    -- Upsert coordinates
    INSERT INTO public.property_coordinates (
        property_id,
        latitude,
        longitude,
        address,
        city,
        state
    ) VALUES (
        p_property_id,
        v_latitude,
        v_longitude,
        v_address,
        v_city,
        v_state
    )
    ON CONFLICT (property_id) 
    DO UPDATE SET
        latitude = EXCLUDED.latitude,
        longitude = EXCLUDED.longitude,
        address = EXCLUDED.address,
        city = EXCLUDED.city,
        state = EXCLUDED.state,
        updated_at = NOW();
    
    RETURN jsonb_build_object(
        'success', true,
        'property_id', p_property_id,
        'latitude', v_latitude,
        'longitude', v_longitude,
        'address', v_address,
        'city', v_city,
        'state', v_state
    );
    
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', SQLERRM,
            'sqlstate', SQLSTATE
        );
END;


Schema: public | Name: reject_visit_request | Type: FUNCTION
  Returns: jsonb | Specific Name: reject_visit_request_128136
  Definition: 
DECLARE
    visit_record RECORD;
    property_title TEXT;
    user_email TEXT;
    result JSONB;
BEGIN
    -- Get visit information
    SELECT v.*, p.title INTO visit_record
    FROM public.property_visits v
    JOIN public.properties p ON v.property_id = p.id
    WHERE v.id = visit_id;
    
    -- If visit not found or already confirmed/rejected
    IF visit_record IS NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit request not found');
    END IF;
    
    IF visit_record.confirmed_at IS NOT NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit already confirmed');
    END IF;
    
    IF visit_record.rejected_at IS NOT NULL THEN
        RETURN jsonb_build_object('success', false, 'message', 'Visit already rejected');
    END IF;
    
    -- Get user email
    SELECT email INTO user_email
    FROM public.profiles
    WHERE id = visit_record.user_id;
    
    -- Update visit to rejected
    UPDATE public.property_visits
    SET 
        rejected_at = NOW(),
        status = 'rejected',
        rejection_reason = reason
    WHERE id = visit_id;
    
    -- Create notification for visitor
    INSERT INTO public.owner_notifications (
        owner_id,
        property_id,
        visit_id,
        title,
        message,
        notification_type
    ) VALUES (
        visit_record.user_id,
        visit_record.property_id,
        visit_record.id,
        'Visit Request Rejected',
        'Your visit request for ' || visit_record.title || ' has been declined' || 
        CASE WHEN reason IS NOT NULL AND reason != '' THEN '. Reason: ' || reason ELSE '' END,
        'visit_rejected'
    );
    
    RETURN jsonb_build_object(
        'success', true, 
        'message', 'Visit rejected successfully',
        'visit_id', visit_id
    );
END;


Schema: public | Name: add_property_to_favorites | Type: FUNCTION
  Returns: boolean | Specific Name: add_property_to_favorites_164468
  Definition: 
DECLARE
  property_exists BOOLEAN;
  already_favorite BOOLEAN;
  v2_property RECORD;
BEGIN
  -- First check if already in favorites
  SELECT EXISTS(
    SELECT 1 FROM property_likes 
    WHERE property_id = p_property_id AND user_id = p_user_id
  ) INTO already_favorite;
  
  -- If already favorite, return success
  IF already_favorite THEN
    RETURN TRUE;
  END IF;
  
  -- Check if property exists in properties table
  SELECT EXISTS(
    SELECT 1 FROM properties WHERE id = p_property_id
  ) INTO property_exists;
  
  -- If property exists in properties, insert directly
  IF property_exists THEN
    INSERT INTO property_likes (property_id, user_id)
    VALUES (p_property_id, p_user_id);
    RETURN TRUE;
  END IF;
  
  -- Property not in properties, check properties_v2
  SELECT EXISTS(
    SELECT 1 FROM properties_v2 WHERE id = p_property_id
  ) INTO property_exists;
  
  IF NOT property_exists THEN
    -- Property doesn't exist in either table
    RETURN FALSE;
  END IF;
  
  -- Property exists in properties_v2 but not in properties
  -- Create shadow record in properties
  SELECT * INTO v2_property FROM properties_v2 WHERE id = p_property_id;
  
  INSERT INTO properties (
    id, 
    owner_id, 
    title, 
    description, 
    price, 
    status,
    created_at,
    updated_at
  ) VALUES (
    p_property_id,
    v2_property.owner_id,
    COALESCE((v2_property.property_details->>'title'), 'Property from V2'),
    'Shadow record for properties_v2',
    COALESCE((v2_property.property_details->>'price')::numeric, 0),
    COALESCE(v2_property.status, 'active'),
    NOW(),
    NOW()
  );
  
  -- Now insert the favorite
  INSERT INTO property_likes (property_id, user_id)
  VALUES (p_property_id, p_user_id);
  
  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'Error adding favorite: %', SQLERRM;
    RETURN FALSE;
END;


Schema: public | Name: extract_land_primary_image | Type: FUNCTION
  Returns: text | Specific Name: extract_land_primary_image_198810
  Definition: 
DECLARE
    image_file JSONB;
    primary_filename TEXT;
BEGIN
    -- Check if imageFiles array exists and has elements
    IF property_details ? 'imageFiles' AND jsonb_array_length(property_details->'imageFiles') > 0 THEN
        -- Iterate through imageFiles array to find the primary image
        FOR image_file IN SELECT jsonb_array_elements(property_details->'imageFiles')
        LOOP
            -- Check if this image is marked as primary
            IF (image_file->>'isPrimary')::boolean = true THEN
                primary_filename := image_file->>'fileName';
                EXIT; -- Found primary image, exit loop
            END IF;
        END LOOP;
        
        -- If no primary image found, return the first image filename
        IF primary_filename IS NULL THEN
            primary_filename := (property_details->'imageFiles'->0)->>'fileName';
        END IF;
    END IF;
    
    -- Check alternative image storage locations
    IF primary_filename IS NULL THEN
        primary_filename := COALESCE(
            property_details->'steps'->'image_upload'->>'primaryImage',
            property_details->'steps'->'images'->>'primaryImage',
            property_details->'media'->'photos'->>'primaryImage',
            property_details->'images'->>'primary'
        );
    END IF;
    
    RETURN primary_filename;
END;


Schema: public | Name: land_flow_type_to_subtype | Type: FUNCTION
  Returns: text | Specific Name: land_flow_type_to_subtype_198687
  Definition: 
BEGIN
    RETURN CASE 
        WHEN flow_type = 'land_sale' THEN 'sale'
        WHEN flow_type LIKE '%land%' THEN 'sale'
        ELSE 'sale'
    END;
END;


Schema: public | Name: sync_property_coordinates | Type: FUNCTION
  Returns: trigger | Specific Name: sync_property_coordinates_206928
  Definition: 
DECLARE
    extracted_lat NUMERIC;
    extracted_lng NUMERIC;
    extracted_address TEXT;
    extracted_city TEXT;
    extracted_state TEXT;
BEGIN
    -- Only process if property_details exists
    IF NEW.property_details IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Extract coordinates using the same logic as our migration query
    -- Strategy 1: property_details.coordinates.lat/lng
    IF NEW.property_details -> 'coordinates' ->> 'lat' IS NOT NULL 
       AND NEW.property_details -> 'coordinates' ->> 'lng' IS NOT NULL
       AND (NEW.property_details -> 'coordinates' ->> 'lat')::numeric BETWEEN -90 AND 90
       AND (NEW.property_details -> 'coordinates' ->> 'lng')::numeric BETWEEN -180 AND 180
       AND (NEW.property_details -> 'coordinates' ->> 'lat')::numeric != 0
       AND (NEW.property_details -> 'coordinates' ->> 'lng')::numeric != 0
    THEN
        extracted_lat := (NEW.property_details -> 'coordinates' ->> 'lat')::numeric;
        extracted_lng := (NEW.property_details -> 'coordinates' ->> 'lng')::numeric;
    
    -- Strategy 2: property_details.coordinates.latitude/longitude
    ELSIF NEW.property_details -> 'coordinates' ->> 'latitude' IS NOT NULL 
          AND NEW.property_details -> 'coordinates' ->> 'longitude' IS NOT NULL
          AND (NEW.property_details -> 'coordinates' ->> 'latitude')::numeric BETWEEN -90 AND 90
          AND (NEW.property_details -> 'coordinates' ->> 'longitude')::numeric BETWEEN -180 AND 180
          AND (NEW.property_details -> 'coordinates' ->> 'latitude')::numeric != 0
          AND (NEW.property_details -> 'coordinates' ->> 'longitude')::numeric != 0
    THEN
        extracted_lat := (NEW.property_details -> 'coordinates' ->> 'latitude')::numeric;
        extracted_lng := (NEW.property_details -> 'coordinates' ->> 'longitude')::numeric;
    
    -- Strategy 3: property_details.mapCoordinates.lat/lng
    ELSIF NEW.property_details -> 'mapCoordinates' ->> 'lat' IS NOT NULL 
          AND NEW.property_details -> 'mapCoordinates' ->> 'lng' IS NOT NULL
          AND (NEW.property_details -> 'mapCoordinates' ->> 'lat')::numeric BETWEEN -90 AND 90
          AND (NEW.property_details -> 'mapCoordinates' ->> 'lng')::numeric BETWEEN -180 AND 180
          AND (NEW.property_details -> 'mapCoordinates' ->> 'lat')::numeric != 0
          AND (NEW.property_details -> 'mapCoordinates' ->> 'lng')::numeric != 0
    THEN
        extracted_lat := (NEW.property_details -> 'mapCoordinates' ->> 'lat')::numeric;
        extracted_lng := (NEW.property_details -> 'mapCoordinates' ->> 'lng')::numeric;
    
    -- Strategy 4: property_details.mapCoordinates.latitude/longitude
    ELSIF NEW.property_details -> 'mapCoordinates' ->> 'latitude' IS NOT NULL 
          AND NEW.property_details -> 'mapCoordinates' ->> 'longitude' IS NOT NULL
          AND (NEW.property_details -> 'mapCoordinates' ->> 'latitude')::numeric BETWEEN -90 AND 90
          AND (NEW.property_details -> 'mapCoordinates' ->> 'longitude')::numeric BETWEEN -180 AND 180
          AND (NEW.property_details -> 'mapCoordinates' ->> 'latitude')::numeric != 0
          AND (NEW.property_details -> 'mapCoordinates' ->> 'longitude')::numeric != 0
    THEN
        extracted_lat := (NEW.property_details -> 'mapCoordinates' ->> 'latitude')::numeric;
        extracted_lng := (NEW.property_details -> 'mapCoordinates' ->> 'longitude')::numeric;
    
    -- Strategy 5: Search in steps for location data
    ELSIF NEW.property_details -> 'steps' IS NOT NULL THEN
        SELECT 
            COALESCE(
                (step_data ->> 'latitude')::numeric,
                (step_data ->> 'lat')::numeric
            ),
            COALESCE(
                (step_data ->> 'longitude')::numeric,
                (step_data ->> 'lng')::numeric
            )
        INTO extracted_lat, extracted_lng
        FROM jsonb_each(NEW.property_details -> 'steps') AS steps(step_key, step_data)
        WHERE step_key ILIKE '%location%'
          AND (
            (step_data ->> 'latitude' IS NOT NULL AND (step_data ->> 'latitude')::numeric BETWEEN -90 AND 90 AND (step_data ->> 'latitude')::numeric != 0)
            OR 
            (step_data ->> 'lat' IS NOT NULL AND (step_data ->> 'lat')::numeric BETWEEN -90 AND 90 AND (step_data ->> 'lat')::numeric != 0)
          )
          AND (
            (step_data ->> 'longitude' IS NOT NULL AND (step_data ->> 'longitude')::numeric BETWEEN -180 AND 180 AND (step_data ->> 'longitude')::numeric != 0)
            OR 
            (step_data ->> 'lng' IS NOT NULL AND (step_data ->> 'lng')::numeric BETWEEN -180 AND 180 AND (step_data ->> 'lng')::numeric != 0)
          )
        LIMIT 1;
    END IF;
    
    -- Extract additional location data
    extracted_address := COALESCE(
        NEW.property_details -> 'address' ->> 'formatted_address',
        NEW.property_details ->> 'address',
        NEW.property_details -> 'location' ->> 'address',
        NEW.property_details -> 'steps' -> 'location_details' ->> 'address',
        (
            SELECT step_data ->> 'address'
            FROM jsonb_each(NEW.property_details -> 'steps') AS steps(step_key, step_data)
            WHERE step_key ILIKE '%location%' 
              AND step_data ->> 'address' IS NOT NULL
            LIMIT 1
        )
    );
    
    extracted_city := COALESCE(
        NEW.property_details -> 'location' ->> 'city',
        NEW.property_details ->> 'city',
        NEW.property_details -> 'steps' -> 'location_details' ->> 'city',
        (
            SELECT step_data ->> 'city'
            FROM jsonb_each(NEW.property_details -> 'steps') AS steps(step_key, step_data)
            WHERE step_key ILIKE '%location%' 
              AND step_data ->> 'city' IS NOT NULL
            LIMIT 1
        ),
        'Hyderabad'
    );
    
    extracted_state := COALESCE(
        NEW.property_details -> 'location' ->> 'state',
        NEW.property_details ->> 'state',
        NEW.property_details -> 'steps' -> 'location_details' ->> 'state',
        (
            SELECT step_data ->> 'state'
            FROM jsonb_each(NEW.property_details -> 'steps') AS steps(step_key, step_data)
            WHERE step_key ILIKE '%location%' 
              AND step_data ->> 'state' IS NOT NULL
            LIMIT 1
        ),
        'Telangana'
    );
    
    -- Insert or update coordinates if valid coordinates were found
    IF extracted_lat IS NOT NULL AND extracted_lng IS NOT NULL THEN
        INSERT INTO property_coordinates (
            property_id,
            latitude,
            longitude,
            address,
            city,
            state,
            created_at,
            updated_at
        )
        VALUES (
            NEW.id,
            extracted_lat,
            extracted_lng,
            extracted_address,
            extracted_city,
            extracted_state,
            NOW(),
            NOW()
        )
        ON CONFLICT (property_id) DO UPDATE SET
            latitude = EXCLUDED.latitude,
            longitude = EXCLUDED.longitude,
            address = EXCLUDED.address,
            city = EXCLUDED.city,
            state = EXCLUDED.state,
            updated_at = NOW();
            
        -- Log successful coordinate extraction
        RAISE INFO 'Coordinates extracted and synced for property %: lat=%, lng=%', NEW.id, extracted_lat, extracted_lng;
    ELSE
        -- Log when no coordinates could be extracted
        RAISE INFO 'No valid coordinates found for property %', NEW.id;
    END IF;
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        -- Log errors but don't fail the property insertion
        RAISE WARNING 'Error syncing coordinates for property %: %', NEW.id, SQLERRM;
        RETURN NEW;
END;


Schema: public | Name: extract_land_latitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_land_latitude_207344
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'land_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'land_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'location_details'->>'latitude'),
       safe_numeric(property_details->'location'->>'latitude'),
       safe_numeric(property_details->'coordinates'->>'lat'),
       safe_numeric(property_details->'coordinates'->>'latitude'),
       safe_numeric(property_details->'flow'->>'latitude'),
       safe_numeric(property_details->>'latitude')
   );
END;


Schema: public | Name: extract_land_longitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_land_longitude_207345
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'land_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'land_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'location_details'->>'longitude'),
       safe_numeric(property_details->'location'->>'longitude'),
       safe_numeric(property_details->'coordinates'->>'lng'),
       safe_numeric(property_details->'coordinates'->>'longitude'),
       safe_numeric(property_details->'flow'->>'longitude'),
       safe_numeric(property_details->>'longitude')
   );
END;


Schema: public | Name: search_land_properties | Type: FUNCTION
  Returns: record | Specific Name: search_land_properties_207346
  Definition: 
DECLARE
    v_total_count BIGINT;
BEGIN
    -- Validate parameters
    IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 1000 THEN
        p_limit := 50;
    END IF;
    
    IF p_offset IS NULL OR p_offset < 0 THEN
        p_offset := 0;
    END IF;

    -- Get total count using helper functions
    SELECT COUNT(*) INTO v_total_count
    FROM properties_v2 p
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND (
          extract_land_flow_type(p.property_details) = 'land_sale'
          OR extract_land_flow_type(p.property_details) LIKE '%land%'
      )
      AND (p_property_subtype IS NULL OR 
           extract_land_property_subtype(p.property_details) ILIKE p_property_subtype)
      AND (p_search_query IS NULL OR 
           extract_land_title(p.property_details) ILIKE '%' || p_search_query || '%')
      AND (p_city IS NULL OR 
           extract_land_city(p.property_details) ILIKE '%' || p_city || '%')
      AND (p_state IS NULL OR 
           extract_land_state(p.property_details) ILIKE '%' || p_state || '%')
      AND (p_min_price IS NULL OR 
           extract_land_price(p.property_details) >= p_min_price)
      AND (p_max_price IS NULL OR 
           extract_land_price(p.property_details) <= p_max_price)
      AND (p_area_min IS NULL OR 
           extract_land_area(p.property_details) >= p_area_min)
      AND (p_area_max IS NULL OR 
           extract_land_area(p.property_details) <= p_area_max);

    -- Return results using helper functions
    RETURN QUERY
    SELECT 
        -- MANDATORY CORE (8 fields)
        p.id,
        p.owner_id,
        p.created_at,
        p.updated_at,
        'land'::TEXT as property_type,
        extract_land_flow_type(p.property_details)::TEXT as flow_type,
        land_flow_type_to_subtype(extract_land_flow_type(p.property_details))::TEXT as subtype,
        v_total_count as total_count,
        
        -- COMMON FIELDS (7 fields) - Using helper functions
        extract_land_title(p.property_details)::TEXT as title,
        extract_land_price(p.property_details) as price,
        extract_land_city(p.property_details)::TEXT as city,
        extract_land_state(p.property_details)::TEXT as state,
        extract_land_area(p.property_details) as area,
        prof.email::TEXT as owner_email,
        COALESCE(p.status, 'active')::TEXT as status,
        
        -- TYPE-SPECIFIC FIELDS (4 fields) - Using NULL for land properties
        NULL::INTEGER as bedrooms,
        NULL::NUMERIC as bathrooms,
        extract_land_area_unit(p.property_details)::TEXT as area_unit,
        extract_land_type(p.property_details)::TEXT as land_type,
        
        -- EXISTING FIELD: Primary image filename
        extract_land_primary_image(p.property_details)::TEXT as primary_image,
        
        -- COORDINATE FIELDS (NEW)
        extract_land_latitude(p.property_details) as latitude,
        extract_land_longitude(p.property_details) as longitude
        
    FROM properties_v2 p
    LEFT JOIN profiles prof ON p.owner_id = prof.id
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND (
          extract_land_flow_type(p.property_details) = 'land_sale'
          OR extract_land_flow_type(p.property_details) LIKE '%land%'
      )
      AND (p_property_subtype IS NULL OR 
           extract_land_property_subtype(p.property_details) ILIKE p_property_subtype)
      AND (p_search_query IS NULL OR 
           extract_land_title(p.property_details) ILIKE '%' || p_search_query || '%')
      AND (p_city IS NULL OR 
           extract_land_city(p.property_details) ILIKE '%' || p_city || '%')
      AND (p_state IS NULL OR 
           extract_land_state(p.property_details) ILIKE '%' || p_state || '%')
      AND (p_min_price IS NULL OR 
           extract_land_price(p.property_details) >= p_min_price)
      AND (p_max_price IS NULL OR 
           extract_land_price(p.property_details) <= p_max_price)
      AND (p_area_min IS NULL OR 
           extract_land_area(p.property_details) >= p_area_min)
      AND (p_area_max IS NULL OR 
           extract_land_area(p.property_details) <= p_area_max)
    ORDER BY p.created_at DESC
    LIMIT p_limit OFFSET p_offset;
    
END;


Schema: public | Name: safe_numeric | Type: FUNCTION
  Returns: numeric | Specific Name: safe_numeric_198744
  Definition: 
BEGIN
    -- Return NULL if input is null or empty string
    IF input_text IS NULL OR trim(input_text) = '' THEN
        RETURN NULL;
    END IF;
    
    -- Remove commas and whitespace, then convert to numeric
    RETURN (regexp_replace(input_text, '[,\s]', '', 'g'))::NUMERIC;
EXCEPTION
    WHEN OTHERS THEN
        -- Return NULL if conversion fails
        RETURN NULL;
END;


Schema: public | Name: mark_notification_read | Type: FUNCTION
  Returns: boolean | Specific Name: mark_notification_read_128158
  Definition: 
DECLARE
    updated_count INTEGER;
BEGIN
    UPDATE public.owner_notifications
    SET is_read = true
    WHERE id = notification_id
    AND owner_id = auth.uid();
    
    GET DIAGNOSTICS updated_count = ROW_COUNT;
    
    RETURN updated_count > 0;
END;


Schema: public | Name: delete_auth_user | Type: FUNCTION
  Returns: void | Specific Name: delete_auth_user_60810
  Definition: 
BEGIN
    -- Delete dependent records first
    DELETE FROM auth.identities WHERE user_id = _user_id;
    DELETE FROM auth.mfa_factors WHERE user_id = _user_id;
    DELETE FROM auth.one_time_tokens WHERE user_id = _user_id;
    DELETE FROM auth.sessions WHERE user_id = _user_id;
    DELETE FROM profiles WHERE id = _user_id;
    DELETE FROM admin_users WHERE user_id = _user_id;

    -- Call Supabase's auth delete function
    PERFORM auth.delete_user(_user_id);
END;


Schema: public | Name: admin_create_user_role | Type: FUNCTION
  Returns: void | Specific Name: admin_create_user_role_79029
  Definition: 
BEGIN
  -- Check if the admin user already exists
  IF NOT EXISTS (SELECT 1 FROM public.admin_users WHERE user_id = admin_create_user_role.user_id) THEN
    INSERT INTO public.admin_users (
      user_id, 
      role_id, 
      created_at, 
      updated_at
    ) VALUES (
      user_id, 
      role_id, 
      NOW(), 
      NOW()
    );
  END IF;
END;


Schema: public | Name: admin_create_profile | Type: FUNCTION
  Returns: void | Specific Name: admin_create_profile_79028
  Definition: 
BEGIN
  -- Insert only if the profile doesn't already exist
  INSERT INTO public.profiles (
    id, 
    email, 
    role, 
    created_at, 
    updated_at
  ) VALUES (
    user_id, 
    user_email, 
    user_role, 
    NOW(), 
    NOW()
  ) ON CONFLICT (id) DO NOTHING;
END;


Schema: public | Name: extract_commercial_price | Type: FUNCTION
  Returns: numeric | Specific Name: extract_commercial_price_198710
  Definition: 
BEGIN
    RETURN COALESCE(
        safe_numeric(property_details->'flow'->>'price'),
        safe_numeric(property_details->'steps'->'com_rent_rental'->>'rentAmount'),
        safe_numeric(property_details->'steps'->'com_rent_rental'->>'monthlyRent'),
        safe_numeric(property_details->'steps'->'com_sale_sale_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'com_sale_sale_details'->>'expectedPrice'),
        safe_numeric(property_details->'steps'->'com_cow_basic_details'->>'price'),
        safe_numeric(property_details->'steps'->'com_cow_basic_details'->>'monthlyPrice'),
        safe_numeric(property_details->'steps'->'commercial_rent_rental'->>'rentAmount'),
        safe_numeric(property_details->'steps'->'commercial_rent_rental'->>'monthlyRent'),
        safe_numeric(property_details->'steps'->'commercial_sale_sale_details'->>'salePrice'),
        safe_numeric(property_details->'steps'->'commercial_sale_sale_details'->>'expectedPrice'),
        safe_numeric(property_details->'steps'->'commercial_coworking_basic_details'->>'price'),
        safe_numeric(property_details->'steps'->'commercial_coworking_basic_details'->>'monthlyPrice'),
        safe_numeric(property_details->'rental'->>'rentAmount'),
        safe_numeric(property_details->'sale'->>'salePrice'),
        safe_numeric(property_details->'sale'->>'expectedPrice'),
        safe_numeric(property_details->>'price')
    );
END;


Schema: public | Name: extract_commercial_title | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_title_198711
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'flow'->>'title',
        property_details->'steps'->'com_rent_basic_details'->>'title',
        property_details->'steps'->'com_sale_basic_details'->>'title',
        property_details->'steps'->'com_cow_basic_details'->>'title',
        property_details->'steps'->'commercial_rent_basic_details'->>'title',
        property_details->'steps'->'commercial_sale_basic_details'->>'title',
        property_details->'steps'->'commercial_coworking_basic_details'->>'title',
        property_details->'basicDetails'->>'title',
        'Commercial Property'
    );
END;


Schema: public | Name: extract_commercial_city | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_city_198712
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'com_rent_location'->>'city',
        property_details->'steps'->'com_sale_location'->>'city',
        property_details->'steps'->'com_cow_location'->>'city',
        property_details->'steps'->'commercial_rent_location'->>'city',
        property_details->'steps'->'commercial_sale_location'->>'city',
        property_details->'steps'->'commercial_coworking_location'->>'city',
        property_details->'steps'->'location_details'->>'city',
        property_details->'location'->>'city'
    );
END;


Schema: public | Name: manual_sync_property_coordinates | Type: FUNCTION
  Returns: json | Specific Name: manual_sync_property_coordinates_206952
  Definition: 
DECLARE
    property_record RECORD;
    result JSON;
BEGIN
    -- Get the property record
    SELECT * INTO property_record
    FROM properties_v2 
    WHERE id = property_id_param;
    
    IF NOT FOUND THEN
        RETURN json_build_object(
            'success', false,
            'error', 'Property not found',
            'property_id', property_id_param
        );
    END IF;
    
    -- Trigger the sync function manually
    PERFORM sync_property_coordinates() FROM (
        SELECT property_record.* 
    ) AS NEW;
    
    -- Check if coordinates were synced
    SELECT json_build_object(
        'success', true,
        'property_id', property_id_param,
        'coordinates_found', CASE WHEN pc.id IS NOT NULL THEN true ELSE false END,
        'latitude', pc.latitude,
        'longitude', pc.longitude,
        'address', pc.address,
        'city', pc.city,
        'state', pc.state
    ) INTO result
    FROM property_coordinates pc
    WHERE pc.property_id = property_id_param;
    
    RETURN COALESCE(result, json_build_object(
        'success', true,
        'property_id', property_id_param,
        'coordinates_found', false,
        'message', 'No valid coordinates found in property_details'
    ));
END;


Schema: public | Name: extract_residential_bedrooms | Type: FUNCTION
  Returns: integer | Specific Name: extract_residential_bedrooms_198624
  Definition: 
BEGIN
   RETURN COALESCE(
       -- Extract from bhkType format (e.g., "2 BHK")
       CASE 
           WHEN property_details->'steps'->'res_rent_basic_details'->>'bhkType' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'steps'->'res_rent_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       CASE 
           WHEN property_details->'steps'->'res_sale_basic_details'->>'bhkType' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'steps'->'res_sale_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       CASE 
           WHEN property_details->'steps'->'res_flat_basic_details'->>'bhkType' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'steps'->'res_flat_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       CASE 
           WHEN property_details->'basicDetails'->>'bhkType' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'basicDetails'->>'bhkType', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       -- Extract from bedrooms field
       CASE 
           WHEN property_details->'steps'->'res_rent_basic_details'->>'bedrooms' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'steps'->'res_rent_basic_details'->>'bedrooms', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       CASE 
           WHEN property_details->'steps'->'res_sale_basic_details'->>'bedrooms' ~ '^[0-9]+' 
           THEN (regexp_match(property_details->'steps'->'res_sale_basic_details'->>'bedrooms', '^([0-9]+)'))[1]::integer
           ELSE NULL 
       END,
       -- Direct numeric values as fallback
       safe_numeric(property_details->'steps'->'res_rent_basic_details'->>'bedrooms')::integer,
       safe_numeric(property_details->'steps'->'res_sale_basic_details'->>'bedrooms')::integer,
       safe_numeric(property_details->'steps'->'res_flat_basic_details'->>'bedrooms')::integer,
       safe_numeric(property_details->'steps'->'res_pg_basic_details'->>'bedrooms')::integer,
       safe_numeric(property_details->'basicDetails'->>'bedrooms')::integer
   );
END;


Schema: public | Name: extract_residential_area | Type: FUNCTION
  Returns: numeric | Specific Name: extract_residential_area_198625
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'res_rent_basic_details'->>'squareFootage'),
       safe_numeric(property_details->'steps'->'res_rent_basic_details'->>'builtUpArea'),
       safe_numeric(property_details->'steps'->'res_sale_basic_details'->>'squareFootage'),
       safe_numeric(property_details->'steps'->'res_sale_basic_details'->>'builtUpArea'),
       safe_numeric(property_details->'steps'->'res_flat_basic_details'->>'squareFootage'),
       safe_numeric(property_details->'steps'->'res_flat_basic_details'->>'builtUpArea'),
       safe_numeric(property_details->'steps'->'res_pg_basic_details'->>'area'),
       safe_numeric(property_details->'basicDetails'->>'builtUpArea'),
       safe_numeric(property_details->'basicDetails'->>'squareFootage')
   );
END;


Schema: public | Name: extract_residential_bathrooms | Type: FUNCTION
  Returns: numeric | Specific Name: extract_residential_bathrooms_198626
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'res_rent_basic_details'->>'bathrooms'),
       safe_numeric(property_details->'steps'->'res_sale_basic_details'->>'bathrooms'),
       safe_numeric(property_details->'steps'->'res_flat_basic_details'->>'bathrooms'),
       safe_numeric(property_details->'steps'->'res_pg_basic_details'->>'bathrooms'),
       safe_numeric(property_details->'basicDetails'->>'bathrooms')
   );
END;


Schema: public | Name: mark_all_notifications_read | Type: FUNCTION
  Returns: integer | Specific Name: mark_all_notifications_read_128180
  Definition: 
DECLARE
    updated_count INTEGER;
BEGIN
    UPDATE public.owner_notifications
    SET is_read = true
    WHERE owner_id = auth.uid()
    AND is_read = false;
    
    GET DIAGNOSTICS updated_count = ROW_COUNT;
    
    RETURN updated_count;
END;


Schema: public | Name: extract_commercial_state | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_state_198713
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'com_rent_location'->>'state',
        property_details->'steps'->'com_sale_location'->>'state',
        property_details->'steps'->'com_cow_location'->>'state',
        property_details->'steps'->'commercial_rent_location'->>'state',
        property_details->'steps'->'commercial_sale_location'->>'state',
        property_details->'steps'->'commercial_coworking_location'->>'state',
        property_details->'steps'->'location_details'->>'state',
        property_details->'location'->>'state'
    );
END;


Schema: public | Name: extract_commercial_area | Type: FUNCTION
  Returns: numeric | Specific Name: extract_commercial_area_198714
  Definition: 
BEGIN
    RETURN COALESCE(
        safe_numeric(property_details->'steps'->'com_rent_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'com_rent_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'com_rent_basic_details'->>'floorArea'),
        safe_numeric(property_details->'steps'->'com_sale_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'com_sale_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'com_sale_basic_details'->>'floorArea'),
        safe_numeric(property_details->'steps'->'com_cow_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'com_cow_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'commercial_rent_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'commercial_rent_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'commercial_sale_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'commercial_sale_basic_details'->>'totalArea'),
        safe_numeric(property_details->'steps'->'commercial_coworking_basic_details'->>'area'),
        safe_numeric(property_details->'steps'->'commercial_coworking_basic_details'->>'totalArea'),
        safe_numeric(property_details->'basicDetails'->>'area'),
        safe_numeric(property_details->'basicDetails'->>'totalArea')
    );
END;


Schema: public | Name: extract_commercial_property_type | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_property_type_198716
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'steps'->'com_rent_basic_details'->>'propertyType',
        property_details->'steps'->'com_sale_basic_details'->>'propertyType',
        property_details->'steps'->'com_cow_basic_details'->>'propertyType',
        property_details->'steps'->'commercial_rent_basic_details'->>'propertyType',
        property_details->'steps'->'commercial_sale_basic_details'->>'propertyType',
        property_details->'steps'->'commercial_coworking_basic_details'->>'propertyType',
        property_details->'basicDetails'->>'propertyType'
    );
END;


Schema: public | Name: extract_residential_primary_image | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_primary_image_198766
  Definition: 
DECLARE
    image_file JSONB;
    primary_filename TEXT;
BEGIN
    -- Check if imageFiles array exists and has elements
    IF property_details ? 'imageFiles' AND jsonb_array_length(property_details->'imageFiles') > 0 THEN
        -- Iterate through imageFiles array to find the primary image
        FOR image_file IN SELECT jsonb_array_elements(property_details->'imageFiles')
        LOOP
            -- Check if this image is marked as primary
            IF (image_file->>'isPrimary')::boolean = true THEN
                primary_filename := image_file->>'fileName';
                EXIT; -- Found primary image, exit loop
            END IF;
        END LOOP;
        
        -- If no primary image found, return the first image filename
        IF primary_filename IS NULL THEN
            primary_filename := (property_details->'imageFiles'->0)->>'fileName';
        END IF;
    END IF;
    
    -- Check alternative image storage locations
    IF primary_filename IS NULL THEN
        primary_filename := COALESCE(
            property_details->'steps'->'image_upload'->>'primaryImage',
            property_details->'steps'->'images'->>'primaryImage',
            property_details->'media'->'photos'->>'primaryImage',
            property_details->'images'->>'primary'
        );
    END IF;
    
    RETURN primary_filename;
END;


Schema: public | Name: extract_residential_price | Type: FUNCTION
  Returns: numeric | Specific Name: extract_residential_price_198627
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'flow'->>'price'),
       safe_numeric(property_details->'steps'->'res_rent_rental'->>'rentAmount'),
       safe_numeric(property_details->'steps'->'res_sale_sale_details'->>'salePrice'),
       safe_numeric(property_details->'steps'->'res_sale_sale_details'->>'expectedPrice'),
       safe_numeric(property_details->'steps'->'res_flat_flatmate_details'->>'rent'),
       safe_numeric(property_details->'steps'->'res_pg_pg_details'->>'rent'),
       safe_numeric(property_details->'steps'->'res_rent_rental'->>'monthlyRent'),
       safe_numeric(property_details->'steps'->'res_flat_flatmate_details'->>'monthlyRent'),
       safe_numeric(property_details->'steps'->'res_pg_pg_details'->>'monthlyRent'),
       safe_numeric(property_details->'rental'->>'rentAmount'),
       safe_numeric(property_details->'sale'->>'expectedPrice'),
       safe_numeric(property_details->>'price')
   );
END;


Schema: public | Name: delete_user_completely | Type: FUNCTION
  Returns: json | Specific Name: delete_user_completely_78340
  Definition: 
DECLARE
  result json;
BEGIN
  -- First delete property images associated with user's properties
  DELETE FROM public.property_images 
  WHERE property_id IN (
    SELECT id FROM public.properties WHERE owner_id = user_id_param
  );
  
  -- Delete the user's properties
  DELETE FROM public.properties WHERE owner_id = user_id_param;
  
  -- Delete from admin_users if applicable
  DELETE FROM public.admin_users WHERE user_id = user_id_param;
  
  -- Delete from profiles
  DELETE FROM public.profiles WHERE id = user_id_param;
  
  -- Finally delete from auth.users
  DELETE FROM auth.users WHERE id = user_id_param;
  
  -- Return success result
  SELECT json_build_object(
    'success', true,
    'message', 'User deleted successfully'
  ) INTO result;
  
  RETURN result;
EXCEPTION WHEN OTHERS THEN
  -- Return error information
  SELECT json_build_object(
    'success', false,
    'message', 'Failed to delete user: ' || SQLERRM,
    'error_code', SQLSTATE
  ) INTO result;
  
  RETURN result;
END;


Schema: public | Name: extract_commercial_primary_image | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_primary_image_198852
  Definition: 
DECLARE
    image_file JSONB;
    primary_filename TEXT;
BEGIN
    -- Check if imageFiles array exists and has elements
    IF property_details ? 'imageFiles' AND jsonb_array_length(property_details->'imageFiles') > 0 THEN
        -- Iterate through imageFiles array to find the primary image
        FOR image_file IN SELECT jsonb_array_elements(property_details->'imageFiles')
        LOOP
            -- Check if this image is marked as primary
            IF (image_file->>'isPrimary')::boolean = true THEN
                primary_filename := image_file->>'fileName';
                EXIT; -- Found primary image, exit loop
            END IF;
        END LOOP;
        
        -- If no primary image found, return the first image filename
        IF primary_filename IS NULL THEN
            primary_filename := (property_details->'imageFiles'->0)->>'fileName';
        END IF;
    END IF;
    
    -- Check alternative image storage locations
    IF primary_filename IS NULL THEN
        primary_filename := COALESCE(
            property_details->'steps'->'image_upload'->>'primaryImage',
            property_details->'steps'->'images'->>'primaryImage',
            property_details->'media'->'photos'->>'primaryImage',
            property_details->'images'->>'primary'
        );
    END IF;
    
    RETURN primary_filename;
END;


Schema: public | Name: commercial_flow_type_to_subtype | Type: FUNCTION
  Returns: text | Specific Name: commercial_flow_type_to_subtype_198717
  Definition: 
BEGIN
    RETURN CASE 
        WHEN flow_type = 'commercial_rent' THEN 'rent'
        WHEN flow_type = 'commercial_sale' THEN 'sale'
        WHEN flow_type = 'commercial_coworking' THEN 'coworking'
        ELSE 'rent'
    END;
END;


Schema: public | Name: request_admin_password_reset | Type: FUNCTION
  Returns: boolean | Specific Name: request_admin_password_reset_60224
  Definition: 
DECLARE
    v_user_id uuid;
    v_is_admin boolean;
BEGIN
    -- Check if user exists and is an admin
    SELECT au.user_id INTO v_user_id
    FROM admin_users au
    JOIN auth.users u ON u.id = au.user_id
    WHERE u.email = admin_email;

    IF v_user_id IS NULL THEN
        RETURN false;
    END IF;

    -- Generate and store reset token
    UPDATE auth.users
    SET 
        recovery_token = encode(gen_random_bytes(32), 'hex'),
        recovery_sent_at = now()
    WHERE id = v_user_id;

    RETURN true;
END;


Schema: public | Name: reset_admin_password | Type: FUNCTION
  Returns: boolean | Specific Name: reset_admin_password_60225
  Definition: 
DECLARE
    v_user_id uuid;
    v_stored_token text;
    v_token_created_at timestamptz;
BEGIN
    -- Get user details
    SELECT 
        id, 
        recovery_token,
        recovery_sent_at
    INTO 
        v_user_id,
        v_stored_token,
        v_token_created_at
    FROM auth.users
    WHERE email = admin_email;

    -- Validate token and expiration
    IF v_user_id IS NULL OR 
       v_stored_token IS NULL OR 
       v_stored_token != token OR
       v_token_created_at < now() - interval '1 hour' THEN
        RETURN false;
    END IF;

    -- Update password and clear reset token
    UPDATE auth.users
    SET 
        encrypted_password = crypt(new_password, gen_salt('bf')),
        recovery_token = NULL,
        recovery_sent_at = NULL,
        updated_at = now()
    WHERE id = v_user_id;

    RETURN true;
END;


Schema: public | Name: create_properties_v2_likes_table_if_not_exists | Type: FUNCTION
  Returns: boolean | Specific Name: create_properties_v2_likes_table_if_not_exists_164590
  Definition: 
BEGIN
    -- Check if the table already exists
    IF NOT EXISTS (
        SELECT FROM pg_tables 
        WHERE schemaname = 'public' 
        AND tablename = 'properties_v2_likes'
    ) THEN
        -- Create the table
        CREATE TABLE public.properties_v2_likes (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            property_id UUID NOT NULL REFERENCES public.properties_v2(id),
            user_id UUID NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
            UNIQUE(property_id, user_id)
        );
        
        -- Add RLS policies for the new table
        ALTER TABLE public.properties_v2_likes ENABLE ROW LEVEL SECURITY;
        
        -- Allow authenticated users to see their own likes
        CREATE POLICY "Users can view their own likes" 
            ON public.properties_v2_likes 
            FOR SELECT 
            TO authenticated 
            USING (auth.uid() = user_id);
            
        -- Allow authenticated users to insert their own likes
        CREATE POLICY "Users can add their own likes" 
            ON public.properties_v2_likes 
            FOR INSERT 
            TO authenticated 
            WITH CHECK (auth.uid() = user_id);
            
        -- Allow authenticated users to delete their own likes
        CREATE POLICY "Users can delete their own likes" 
            ON public.properties_v2_likes 
            FOR DELETE 
            TO authenticated 
            USING (auth.uid() = user_id);
            
        RETURN TRUE;
    ELSE
        RETURN TRUE; -- Table already exists
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error creating properties_v2_likes table: %', SQLERRM;
        RETURN FALSE;
END;


Schema: public | Name: add_property_v2_to_likes | Type: FUNCTION
  Returns: boolean | Specific Name: add_property_v2_to_likes_164591
  Definition: 
DECLARE
    property_exists BOOLEAN;
    already_favorite BOOLEAN;
BEGIN
    -- First check if already in favorites
    SELECT EXISTS(
        SELECT 1 FROM property_likes 
        WHERE property_id = p_property_id AND user_id = p_user_id
    ) INTO already_favorite;
    
    -- If already favorite, return success
    IF already_favorite THEN
        RETURN TRUE;
    END IF;
    
    -- Check if property exists in properties_v2
    SELECT EXISTS(
        SELECT 1 FROM properties_v2 WHERE id = p_property_id
    ) INTO property_exists;
    
    -- If property doesn't exist, return false
    IF NOT property_exists THEN
        RETURN FALSE;
    END IF;
    
    -- Insert directly into property_likes, bypassing the foreign key constraint
    INSERT INTO property_likes (property_id, user_id)
    VALUES (p_property_id, p_user_id);
    
    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error adding property_v2 to likes: %', SQLERRM;
        RETURN FALSE;
END;


Schema: public | Name: create_direct_favorite | Type: FUNCTION
  Returns: boolean | Specific Name: create_direct_favorite_164592
  Definition: 
BEGIN
    -- Use a direct SQL approach to bypass constraints
    EXECUTE 'INSERT INTO property_likes (property_id, user_id) VALUES ($1, $2)'
    USING p_property_id, p_user_id;
    
    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RAISE NOTICE 'Error creating direct favorite: %', SQLERRM;
        RETURN FALSE;
END;


Schema: public | Name: matches_commercial_subtype | Type: FUNCTION
  Returns: boolean | Specific Name: matches_commercial_subtype_198718
  Definition: 
DECLARE
    flow_type TEXT;
BEGIN
    IF p_subtype IS NULL THEN
        RETURN TRUE;
    END IF;
    
    flow_type := extract_commercial_flow_type(property_details);
    
    RETURN CASE 
        WHEN p_subtype = 'rent' THEN flow_type = 'commercial_rent'
        WHEN p_subtype = 'sale' THEN flow_type = 'commercial_sale'
        WHEN p_subtype = 'coworking' THEN flow_type = 'commercial_coworking'
        ELSE TRUE
    END;
END;


Schema: public | Name: extract_commercial_latitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_commercial_latitude_207368
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'com_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'com_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'com_cow_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_coworking_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'location_details'->>'latitude'),
       safe_numeric(property_details->'location'->>'latitude'),
       safe_numeric(property_details->'coordinates'->>'lat'),
       safe_numeric(property_details->'coordinates'->>'latitude'),
       safe_numeric(property_details->'flow'->>'latitude'),
       safe_numeric(property_details->>'latitude')
   );
END;


Schema: public | Name: extract_commercial_longitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_commercial_longitude_207369
  Definition: 
BEGIN
   RETURN COALESCE(
       safe_numeric(property_details->'steps'->'com_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'com_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'com_cow_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_coworking_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'location_details'->>'longitude'),
       safe_numeric(property_details->'location'->>'longitude'),
       safe_numeric(property_details->'coordinates'->>'lng'),
       safe_numeric(property_details->'coordinates'->>'longitude'),
       safe_numeric(property_details->'flow'->>'longitude'),
       safe_numeric(property_details->>'longitude')
   );
END;


Schema: public | Name: search_commercial_properties | Type: FUNCTION
  Returns: record | Specific Name: search_commercial_properties_207370
  Definition: 
DECLARE
    v_total_count BIGINT;
BEGIN
    -- Validate parameters
    IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 1000 THEN
        p_limit := 50;
    END IF;
    
    IF p_offset IS NULL OR p_offset < 0 THEN
        p_offset := 0;
    END IF;

    -- Get total count using helper functions
    SELECT COUNT(*) INTO v_total_count
    FROM properties_v2 p
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND extract_commercial_flow_type(p.property_details) IN ('commercial_rent', 'commercial_sale', 'commercial_coworking')
      AND matches_commercial_subtype(p.property_details, p_subtype)
      AND (p_property_subtype IS NULL OR 
           extract_commercial_property_type(p.property_details) ILIKE p_property_subtype)
      AND (p_search_query IS NULL OR 
           extract_commercial_title(p.property_details) ILIKE '%' || p_search_query || '%')
      AND (p_city IS NULL OR 
           extract_commercial_city(p.property_details) ILIKE '%' || p_city || '%')
      AND (p_state IS NULL OR 
           extract_commercial_state(p.property_details) ILIKE '%' || p_state || '%')
      AND (p_min_price IS NULL OR 
           extract_commercial_price(p.property_details) >= p_min_price)
      AND (p_max_price IS NULL OR 
           extract_commercial_price(p.property_details) <= p_max_price)
      AND (p_area_min IS NULL OR 
           extract_commercial_area(p.property_details) >= p_area_min)
      AND (p_area_max IS NULL OR 
           extract_commercial_area(p.property_details) <= p_area_max);

    -- Return the normalized results with standardized 23-column structure (21 + 2 coordinates)
    RETURN QUERY
    SELECT 
        -- MANDATORY CORE (8 fields)
        p.id,
        p.owner_id,
        p.created_at,
        p.updated_at,
        'commercial'::TEXT as property_type,
        extract_commercial_flow_type(p.property_details)::TEXT as flow_type,
        commercial_flow_type_to_subtype(extract_commercial_flow_type(p.property_details))::TEXT as subtype,
        v_total_count as total_count,
        
        -- COMMON FIELDS (7 fields) - Using helper functions
        extract_commercial_title(p.property_details)::TEXT as title,
        extract_commercial_price(p.property_details) as price,
        extract_commercial_city(p.property_details)::TEXT as city,
        extract_commercial_state(p.property_details)::TEXT as state,
        extract_commercial_area(p.property_details) as area,
        prof.email::TEXT as owner_email,
        COALESCE(p.status, 'active')::TEXT as status,
        
        -- TYPE-SPECIFIC FIELDS (4 fields) - NULL for commercial (no bedrooms/bathrooms)
        NULL::INTEGER as bedrooms,
        NULL::NUMERIC as bathrooms,
        'sq_ft'::TEXT as area_unit,
        NULL::TEXT as land_type,
        
        -- EXISTING FIELD: Primary image filename
        extract_commercial_primary_image(p.property_details)::TEXT as primary_image,
        
        -- COORDINATE FIELDS (NEW)
        extract_commercial_latitude(p.property_details) as latitude,
        extract_commercial_longitude(p.property_details) as longitude
        
    FROM properties_v2 p
    LEFT JOIN profiles prof ON p.owner_id = prof.id
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND extract_commercial_flow_type(p.property_details) IN ('commercial_rent', 'commercial_sale', 'commercial_coworking')
      AND matches_commercial_subtype(p.property_details, p_subtype)
      AND (p_property_subtype IS NULL OR 
           extract_commercial_property_type(p.property_details) ILIKE p_property_subtype)
      AND (p_search_query IS NULL OR 
           extract_commercial_title(p.property_details) ILIKE '%' || p_search_query || '%')
      AND (p_city IS NULL OR 
           extract_commercial_city(p.property_details) ILIKE '%' || p_city || '%')
      AND (p_state IS NULL OR 
           extract_commercial_state(p.property_details) ILIKE '%' || p_state || '%')
      AND (p_min_price IS NULL OR 
           extract_commercial_price(p.property_details) >= p_min_price)
      AND (p_max_price IS NULL OR 
           extract_commercial_price(p.property_details) <= p_max_price)
      AND (p_area_min IS NULL OR 
           extract_commercial_area(p.property_details) >= p_area_min)
      AND (p_area_max IS NULL OR 
           extract_commercial_area(p.property_details) <= p_area_max)
    ORDER BY p.created_at DESC
    LIMIT p_limit OFFSET p_offset;
    
END;


Schema: auth | Name: role | Type: FUNCTION
  Returns: text | Specific Name: role_29656
  Definition: 
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.role', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')
  )::text


Schema: auth | Name: uid | Type: FUNCTION
  Returns: uuid | Specific Name: uid_29657
  Definition: 
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.sub', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')
  )::uuid


Schema: auth | Name: email | Type: FUNCTION
  Returns: text | Specific Name: email_29654
  Definition: 
  select 
  coalesce(
    nullif(current_setting('request.jwt.claim.email', true), ''),
    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')
  )::text


Schema: public | Name: insert_favorite_directly | Type: FUNCTION
  Returns: boolean | Specific Name: insert_favorite_directly_164631
  Definition: 
BEGIN
  -- First check if already in favorites
  IF EXISTS (
    SELECT 1 FROM property_likes 
    WHERE property_id = p_property_id AND user_id = p_user_id
  ) THEN
    RETURN TRUE;
  END IF;

  -- Use a more direct approach - raw SQL with execute
  BEGIN
    EXECUTE 'INSERT INTO property_likes (property_id, user_id) VALUES ($1, $2)'
    USING p_property_id, p_user_id;
    RETURN TRUE;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE NOTICE 'Direct insert failed: %', SQLERRM;
      -- Last resort - try to disable triggers temporarily
      EXECUTE 'ALTER TABLE property_likes DISABLE TRIGGER ALL';
      EXECUTE 'INSERT INTO property_likes (property_id, user_id) VALUES ($1, $2)'
      USING p_property_id, p_user_id;
      EXECUTE 'ALTER TABLE property_likes ENABLE TRIGGER ALL';
      RETURN TRUE;
  END;
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'All insert attempts failed: %', SQLERRM;
    RETURN FALSE;
END;


Schema: public | Name: check_coordinate_sync_status | Type: FUNCTION
  Returns: record | Specific Name: check_coordinate_sync_status_207016
  Definition: 
BEGIN
    RETURN QUERY
    SELECT 
        t.tgname::TEXT as trigger_name,
        c.relname::TEXT as table_name,
        tgenabled = 'O' as trigger_enabled,
        CASE 
            WHEN t.tgname LIKE '%insert%' THEN 'INSERT'
            WHEN t.tgname LIKE '%update%' THEN 'UPDATE'
            WHEN t.tgname LIKE '%delete%' THEN 'DELETE'
            ELSE 'OTHER'
        END::TEXT as trigger_event,
        CASE 
            WHEN (t.tgtype & 1) = 1 THEN 'BEFORE'
            WHEN (t.tgtype & 64) = 64 THEN 'AFTER'
            ELSE 'INSTEAD OF'
        END::TEXT as trigger_timing,
        p.proname::TEXT as trigger_function
    FROM pg_trigger t
    JOIN pg_class c ON t.tgrelid = c.oid
    JOIN pg_proc p ON t.tgfoid = p.oid
    WHERE t.tgname LIKE '%sync_coordinates%'
      AND c.relname = 'properties_v2'
      AND NOT t.tgisinternal
    ORDER BY t.tgname;
END;


Schema: public | Name: create_update_coordinates_function | Type: FUNCTION
  Returns: void | Specific Name: create_update_coordinates_function_122678
  Definition: 
BEGIN
  -- Check if the function already exists
  IF NOT EXISTS (
    SELECT 1 
    FROM pg_proc p 
    JOIN pg_namespace n ON p.pronamespace = n.oid 
    WHERE n.nspname = 'public' 
    AND p.proname = 'update_property_coordinates'
  ) THEN
    -- Create the function
    EXECUTE '
    CREATE OR REPLACE FUNCTION public.update_property_coordinates(
      p_property_id uuid,
      p_lat double precision,
      p_lng double precision
    ) RETURNS boolean
    LANGUAGE plpgsql
    SECURITY DEFINER
    AS $func$
    DECLARE
      v_success boolean;
      v_property_details jsonb;
    BEGIN
      -- Get current property_details
      SELECT property_details INTO v_property_details 
      FROM public.properties 
      WHERE id = p_property_id;
      
      -- Create new property_details with coordinates in multiple formats
      IF v_property_details IS NULL THEN
        v_property_details := ''{}''::jsonb;
      END IF;
      
      -- Update property_details with all coordinate formats
      v_property_details := jsonb_set(
        v_property_details, 
        ''{coordinates}'', 
        json_build_object(''lat'', p_lat, ''lng'', p_lng)::jsonb
      );
      
      v_property_details := jsonb_set(
        v_property_details, 
        ''{mapCoordinates}'', 
        json_build_object(''lat'', p_lat, ''lng'', p_lng)::jsonb
      );
      
      v_property_details := jsonb_set(
        v_property_details, 
        ''{lat}'', 
        to_jsonb(p_lat)
      );
      
      v_property_details := jsonb_set(
        v_property_details, 
        ''{lng}'', 
        to_jsonb(p_lng)
      );
      
      v_property_details := jsonb_set(
        v_property_details, 
        ''{latitude}'', 
        to_jsonb(p_lat)
      );
      
      v_property_details := jsonb_set(
        v_property_details, 
        ''{longitude}'', 
        to_jsonb(p_lng)
      );
      
      -- Update the property with new details
      UPDATE public.properties
      SET property_details = v_property_details
      WHERE id = p_property_id;
      
      GET DIAGNOSTICS v_success = ROW_COUNT;
      
      RETURN v_success = 1;
    END;
    $func$;
    ';
  END IF;
END;


Schema: public | Name: get_properties_by_owner | Type: FUNCTION
  Returns: record | Specific Name: get_properties_by_owner_198986
  Definition: 
DECLARE
    v_total_count BIGINT;
BEGIN
    -- Validate parameters
    IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 1000 THEN
        p_limit := 50;
    END IF;
    
    IF p_offset IS NULL OR p_offset < 0 THEN
        p_offset := 0;
    END IF;

    -- Validate owner_id
    IF p_owner_id IS NULL THEN
        RAISE EXCEPTION 'Owner ID cannot be null';
    END IF;

    -- Get total count of properties for this owner with filters
    SELECT COUNT(*) INTO v_total_count
    FROM properties_v2 p
    WHERE p.owner_id = p_owner_id
      AND (p_status IS NULL OR p.status = p_status OR (p_status = 'active' AND p.status IS DISTINCT FROM 'deleted'))
      AND (p_property_type IS NULL OR 
           CASE 
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'residential_%' THEN 'residential'
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'commercial_%' THEN 'commercial'
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'land_%' THEN 'land'
               ELSE 'residential'
           END = p_property_type)
      AND (p_search_query IS NULL OR 
           COALESCE(
               p.property_details->'flow'->>'title',
               p.property_details->'steps'->'res_rent_basic_details'->>'title',
               p.property_details->'steps'->'res_sale_basic_details'->>'title',
               p.property_details->'steps'->'res_flat_basic_details'->>'title',
               p.property_details->'steps'->'res_pg_basic_details'->>'title',
               p.property_details->'steps'->'com_rent_basic_details'->>'title',
               p.property_details->'steps'->'com_sale_basic_details'->>'title',
               p.property_details->'steps'->'com_cow_basic_details'->>'title',
               p.property_details->'steps'->'land_sale_basic_details'->>'title',
               p.property_details->'steps'->'land_basic_details'->>'title',
               p.property_details->'basicDetails'->>'title',
               'Property'
           ) ILIKE '%' || p_search_query || '%');

    -- Return results for all property types
    RETURN QUERY
    SELECT 
        -- MANDATORY CORE (8 fields)
        p.id,
        p.owner_id,
        p.created_at,
        p.updated_at,
        
        -- Determine property type based on flow_type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN 'residential'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'commercial_%' THEN 'commercial'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN 'land'
            ELSE 'residential'
        END::TEXT as property_type,
        
        -- Flow type
        COALESCE(
            p.property_details->'flow'->>'flowType',
            p.property_details->>'flowType',
            'residential_rent'
        )::TEXT as flow_type,
        
        -- Subtype based on flow type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_flatmates' THEN 'flatmates'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_pghostel' THEN 'pghostel'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_coworking' THEN 'coworking'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'land_sale' THEN 'sale'
            ELSE 'rent'
        END::TEXT as subtype,
        
        v_total_count as total_count,
        
        -- COMMON FIELDS (7 fields)
        -- Title (works for all property types)
        COALESCE(
            p.property_details->'flow'->>'title',
            p.property_details->'steps'->'res_rent_basic_details'->>'title',
            p.property_details->'steps'->'res_sale_basic_details'->>'title',
            p.property_details->'steps'->'res_flat_basic_details'->>'title',
            p.property_details->'steps'->'res_pg_basic_details'->>'title',
            p.property_details->'steps'->'com_rent_basic_details'->>'title',
            p.property_details->'steps'->'com_sale_basic_details'->>'title',
            p.property_details->'steps'->'com_cow_basic_details'->>'title',
            p.property_details->'steps'->'land_sale_basic_details'->>'title',
            p.property_details->'steps'->'land_basic_details'->>'title',
            p.property_details->'basicDetails'->>'title',
            'Property'
        )::TEXT as title,
        
        -- Price (works for all property types)
        COALESCE(
            safe_numeric(p.property_details->'flow'->>'price'),
            safe_numeric(p.property_details->'steps'->'res_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'expectedPrice'),
            safe_numeric(p.property_details->'steps'->'com_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'expectedPrice'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'price'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'salePrice'),
            safe_numeric(p.property_details->>'price')
        ) as price,
        
        -- City (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'city',
            p.property_details->'steps'->'res_sale_location'->>'city',
            p.property_details->'steps'->'res_flat_location'->>'city',
            p.property_details->'steps'->'res_pg_location'->>'city',
            p.property_details->'steps'->'com_rent_location'->>'city',
            p.property_details->'steps'->'com_sale_location'->>'city',
            p.property_details->'steps'->'com_cow_location'->>'city',
            p.property_details->'steps'->'land_sale_location'->>'city',
            p.property_details->'steps'->'land_location'->>'city',
            p.property_details->'location'->>'city'
        )::TEXT as city,
        
        -- State (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'state',
            p.property_details->'steps'->'res_sale_location'->>'state',
            p.property_details->'steps'->'res_flat_location'->>'state',
            p.property_details->'steps'->'res_pg_location'->>'state',
            p.property_details->'steps'->'com_rent_location'->>'state',
            p.property_details->'steps'->'com_sale_location'->>'state',
            p.property_details->'steps'->'com_cow_location'->>'state',
            p.property_details->'steps'->'land_sale_location'->>'state',
            p.property_details->'steps'->'land_location'->>'state',
            p.property_details->'location'->>'state'
        )::TEXT as state,
        
        -- Area (works for all property types)
        COALESCE(
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'com_rent_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'com_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_basic_details'->>'area'),
            safe_numeric(p.property_details->'basicDetails'->>'area')
        ) as area,
        
        prof.email::TEXT as owner_email,
        COALESCE(p.status, 'active')::TEXT as status,
        
        -- TYPE-SPECIFIC FIELDS (4 fields)
        -- Bedrooms (only for residential)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    -- Extract from bhkType format (e.g., "2 BHK")
                    CASE 
                        WHEN p.property_details->'steps'->'res_rent_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_rent_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    CASE 
                        WHEN p.property_details->'steps'->'res_sale_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_sale_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bedrooms')::integer
                )
            ELSE NULL
        END as bedrooms,
        
        -- Bathrooms (only for residential)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'basicDetails'->>'bathrooms')
                )
            ELSE NULL
        END as bathrooms,
        
        -- Area unit
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'areaUnit',
                    p.property_details->'steps'->'land_basic_details'->>'areaUnit',
                    'sq_ft'
                )
            ELSE 'sq_ft'
        END::TEXT as area_unit,
        
        -- Land type (only for land properties)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'landType',
                    p.property_details->'steps'->'land_basic_details'->>'landType',
                    p.property_details->'basicDetails'->>'landType',
                    'agricultural'
                )
            ELSE NULL
        END::TEXT as land_type,
        
        -- Primary image (works for all property types)
        COALESCE(
            -- Check imageFiles array first
            CASE 
                WHEN p.property_details ? 'imageFiles' AND jsonb_array_length(p.property_details->'imageFiles') > 0 THEN
                    (p.property_details->'imageFiles'->0)->>'fileName'
                ELSE NULL 
            END,
            -- Check alternative locations
            p.property_details->'steps'->'image_upload'->>'primaryImage',
            p.property_details->'steps'->'images'->>'primaryImage',
            p.property_details->'media'->'photos'->>'primaryImage',
            p.property_details->'images'->>'primary'
        )::TEXT as primary_image
        
    FROM properties_v2 p
    LEFT JOIN profiles prof ON p.owner_id = prof.id
    WHERE p.owner_id = p_owner_id
      AND (p_status IS NULL OR p.status = p_status OR (p_status = 'active' AND p.status IS DISTINCT FROM 'deleted'))
      AND (p_property_type IS NULL OR 
           CASE 
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'residential_%' THEN 'residential'
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'commercial_%' THEN 'commercial'
               WHEN COALESCE(
                   p.property_details->'flow'->>'flowType',
                   p.property_details->>'flowType',
                   'residential_rent'
               ) LIKE 'land_%' THEN 'land'
               ELSE 'residential'
           END = p_property_type)
      AND (p_search_query IS NULL OR 
           COALESCE(
               p.property_details->'flow'->>'title',
               p.property_details->'steps'->'res_rent_basic_details'->>'title',
               p.property_details->'steps'->'res_sale_basic_details'->>'title',
               p.property_details->'steps'->'res_flat_basic_details'->>'title',
               p.property_details->'steps'->'res_pg_basic_details'->>'title',
               p.property_details->'steps'->'com_rent_basic_details'->>'title',
               p.property_details->'steps'->'com_sale_basic_details'->>'title',
               p.property_details->'steps'->'com_cow_basic_details'->>'title',
               p.property_details->'steps'->'land_sale_basic_details'->>'title',
               p.property_details->'steps'->'land_basic_details'->>'title',
               p.property_details->'basicDetails'->>'title',
               'Property'
           ) ILIKE '%' || p_search_query || '%')
    ORDER BY p.created_at DESC
    LIMIT p_limit OFFSET p_offset;
    
END;


Schema: public | Name: update_coordinates_directly | Type: FUNCTION
  Returns: boolean | Specific Name: update_coordinates_directly_122700
  Definition: 
DECLARE
  success BOOLEAN;
BEGIN
  -- Update property_details using jsonb_set to preserve other data
  UPDATE properties
  SET property_details = 
    CASE 
      WHEN property_details IS NULL THEN 
        jsonb_build_object('coordinates', jsonb_build_object('lat', lat, 'lng', lng))
      ELSE
        jsonb_set(
          jsonb_set(
            property_details,
            '{coordinates}',
            jsonb_build_object('lat', lat, 'lng', lng),
            true
          ),
          '{mapCoordinates}',
          jsonb_build_object('lat', lat, 'lng', lng),
          true
        )
    END
  WHERE id = property_id;
  
  GET DIAGNOSTICS success = ROW_COUNT;
  RETURN success > 0;
END;


Schema: public | Name: insert_property_image_as_moderator | Type: FUNCTION
  Returns: jsonb | Specific Name: insert_property_image_as_moderator_163042
  Definition: 
DECLARE
  v_user_id UUID;
  v_is_moderator BOOLEAN;
  v_result JSONB;
  v_image_id UUID;
BEGIN
  -- Get the current user's ID
  v_user_id := auth.uid();
  
  -- Check if the user is a moderator
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = v_user_id
    AND ar.role_type IN ('property_moderator', 'admin', 'super_admin')
  ) INTO v_is_moderator;
  
  -- If not a moderator, return error
  IF NOT v_is_moderator THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'User does not have property moderator privileges'
    );
  END IF;
  
  -- If property doesn't exist, return error
  IF NOT EXISTS (SELECT 1 FROM properties WHERE id = p_property_id) THEN
    RETURN jsonb_build_object(
      'success', false,
      'error', 'Property does not exist'
    );
  END IF;
  
  -- Generate a new UUID for the image
  v_image_id := gen_random_uuid();
  
  -- Insert the image record
  INSERT INTO property_images (
    id,
    property_id,
    url,
    is_primary,
    display_order,
    created_at
  ) VALUES (
    v_image_id,
    p_property_id,
    p_url,
    p_is_primary,
    p_display_order,
    NOW()
  );
  
  -- Return success response with image data
  SELECT jsonb_build_object(
    'id', v_image_id,
    'property_id', p_property_id,
    'url', p_url,
    'is_primary', p_is_primary,
    'display_order', p_display_order,
    'created_at', NOW()
  ) INTO v_result;
  
  RETURN v_result;
END;


Schema: public | Name: update_property_coordinates | Type: FUNCTION
  Returns: jsonb | Specific Name: update_property_coordinates_125702
  Definition: 
DECLARE
  result JSONB;
BEGIN
  -- Update the property with the new coordinates
  UPDATE properties
  SET property_details = jsonb_set(
    COALESCE(property_details, '{}'::jsonb),
    '{coordinates}',
    jsonb_build_object('lat', p_lat, 'lng', p_lng),
    true
  ),
  updated_at = NOW()
  WHERE id = p_id
  RETURNING jsonb_build_object('success', true, 'id', id, 'coordinates', property_details->'coordinates') INTO result;
  
  -- If no rows were updated, it means the property doesn't exist
  IF result IS NULL THEN
    RETURN jsonb_build_object('success', false, 'error', 'Property not found');
  END IF;
  
  RETURN result;
END;


Schema: public | Name: get_owner_properties_count | Type: FUNCTION
  Returns: record | Specific Name: get_owner_properties_count_198988
  Definition: 
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_properties,
        COUNT(CASE WHEN COALESCE(status, 'active') != 'deleted' THEN 1 END)::INTEGER as active_properties,
        COUNT(CASE WHEN status = 'draft' THEN 1 END)::INTEGER as draft_properties,
        COUNT(CASE WHEN status = 'deleted' THEN 1 END)::INTEGER as deleted_properties,
        COUNT(CASE 
            WHEN COALESCE(
                property_details->'flow'->>'flowType',
                property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN 1 
        END)::INTEGER as residential_count,
        COUNT(CASE 
            WHEN COALESCE(
                property_details->'flow'->>'flowType',
                property_details->>'flowType',
                'residential_rent'
            ) LIKE 'commercial_%' THEN 1 
        END)::INTEGER as commercial_count,
        COUNT(CASE 
            WHEN COALESCE(
                property_details->'flow'->>'flowType',
                property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN 1 
        END)::INTEGER as land_count
    FROM properties_v2
    WHERE owner_id = p_owner_id;
END;


Schema: public | Name: extract_general_latitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_general_latitude_207392
  Definition: 
BEGIN
   RETURN COALESCE(
       -- Residential location steps
       safe_numeric(property_details->'steps'->'res_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_flat_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'res_pg_location'->>'latitude'),
       -- Commercial location steps
       safe_numeric(property_details->'steps'->'com_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'com_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'com_cow_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_rent_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'commercial_coworking_location'->>'latitude'),
       -- Land location steps
       safe_numeric(property_details->'steps'->'land_sale_location'->>'latitude'),
       safe_numeric(property_details->'steps'->'land_location'->>'latitude'),
       -- Generic location fields
       safe_numeric(property_details->'steps'->'location_details'->>'latitude'),
       safe_numeric(property_details->'location'->>'latitude'),
       safe_numeric(property_details->'coordinates'->>'lat'),
       safe_numeric(property_details->'coordinates'->>'latitude'),
       safe_numeric(property_details->'flow'->>'latitude'),
       safe_numeric(property_details->>'latitude')
   );
END;


Schema: public | Name: extract_general_longitude | Type: FUNCTION
  Returns: numeric | Specific Name: extract_general_longitude_207393
  Definition: 
BEGIN
   RETURN COALESCE(
       -- Residential location steps
       safe_numeric(property_details->'steps'->'res_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_flat_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'res_pg_location'->>'longitude'),
       -- Commercial location steps
       safe_numeric(property_details->'steps'->'com_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'com_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'com_cow_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_rent_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'commercial_coworking_location'->>'longitude'),
       -- Land location steps
       safe_numeric(property_details->'steps'->'land_sale_location'->>'longitude'),
       safe_numeric(property_details->'steps'->'land_location'->>'longitude'),
       -- Generic location fields
       safe_numeric(property_details->'steps'->'location_details'->>'longitude'),
       safe_numeric(property_details->'location'->>'longitude'),
       safe_numeric(property_details->'coordinates'->>'lng'),
       safe_numeric(property_details->'coordinates'->>'longitude'),
       safe_numeric(property_details->'flow'->>'longitude'),
       safe_numeric(property_details->>'longitude')
   );
END;


Schema: public | Name: get_latest_properties | Type: FUNCTION
  Returns: record | Specific Name: get_latest_properties_207394
  Definition: 
DECLARE
    v_total_count BIGINT;
BEGIN
    -- Validate limit parameter
    IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 1000 THEN
        p_limit := 50;
    END IF;

    -- Get total count of active properties
    SELECT COUNT(*) INTO v_total_count
    FROM properties_v2 p
    WHERE p.status IS DISTINCT FROM 'deleted';

    -- Return results for all property types
    RETURN QUERY
    SELECT 
        -- MANDATORY CORE (8 fields)
        p.id,
        p.owner_id,
        p.created_at,
        p.updated_at,
        
        -- Determine property type based on flow_type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN 'residential'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'commercial_%' THEN 'commercial'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN 'land'
            ELSE 'residential'
        END::TEXT as property_type,
        
        -- Flow type
        COALESCE(
            p.property_details->'flow'->>'flowType',
            p.property_details->>'flowType',
            'residential_rent'
        )::TEXT as flow_type,
        
        -- Subtype based on flow type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_flatmates' THEN 'flatmates'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_pghostel' THEN 'pghostel'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_coworking' THEN 'coworking'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'land_sale' THEN 'sale'
            ELSE 'rent'
        END::TEXT as subtype,
        
        v_total_count as total_count,
        
        -- COMMON FIELDS (7 fields)
        -- Title (works for all property types)
        COALESCE(
            p.property_details->'flow'->>'title',
            p.property_details->'steps'->'res_rent_basic_details'->>'title',
            p.property_details->'steps'->'res_sale_basic_details'->>'title',
            p.property_details->'steps'->'res_flat_basic_details'->>'title',
            p.property_details->'steps'->'res_pg_basic_details'->>'title',
            p.property_details->'steps'->'com_rent_basic_details'->>'title',
            p.property_details->'steps'->'com_sale_basic_details'->>'title',
            p.property_details->'steps'->'com_cow_basic_details'->>'title',
            p.property_details->'steps'->'land_sale_basic_details'->>'title',
            p.property_details->'steps'->'land_basic_details'->>'title',
            p.property_details->'basicDetails'->>'title',
            'Property'
        )::TEXT as title,
        
        -- Price (ENHANCED - includes all flatmates price paths)
        COALESCE(
            safe_numeric(p.property_details->'flow'->>'price'),
            -- Residential rent paths
            safe_numeric(p.property_details->'steps'->'res_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'res_rent_rental'->>'monthlyRent'),
            -- Residential sale paths
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'expectedPrice'),
            -- Flatmates specific paths (ADDED)
            safe_numeric(p.property_details->'steps'->'res_flat_flatmate_details'->>'rent'),
            safe_numeric(p.property_details->'steps'->'res_flat_flatmate_details'->>'monthlyRent'),
            safe_numeric(p.property_details->'steps'->'res_flat_flatmate_details'->>'rentPerMonth'),
            safe_numeric(p.property_details->'steps'->'res_flat_flatmate_details'->>'monthlyPrice'),
            -- PG/Hostel specific paths (ADDED)
            safe_numeric(p.property_details->'steps'->'res_pg_pg_details'->>'rent'),
            safe_numeric(p.property_details->'steps'->'res_pg_pg_details'->>'monthlyRent'),
            safe_numeric(p.property_details->'steps'->'res_pg_pg_details'->>'monthlyPrice'),
            -- Commercial paths
            safe_numeric(p.property_details->'steps'->'com_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'com_rent_rental'->>'monthlyRent'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'expectedPrice'),
            safe_numeric(p.property_details->'steps'->'com_cow_basic_details'->>'price'),
            safe_numeric(p.property_details->'steps'->'com_cow_basic_details'->>'monthlyPrice'),
            -- Land paths
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'price'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'expectedPrice'),
            -- Fallback paths
            safe_numeric(p.property_details->'rental'->>'rentAmount'),
            safe_numeric(p.property_details->'sale'->>'expectedPrice'),
            safe_numeric(p.property_details->>'price')
        ) as price,
        
        -- City (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'city',
            p.property_details->'steps'->'res_sale_location'->>'city',
            p.property_details->'steps'->'res_flat_location'->>'city',
            p.property_details->'steps'->'res_pg_location'->>'city',
            p.property_details->'steps'->'com_rent_location'->>'city',
            p.property_details->'steps'->'com_sale_location'->>'city',
            p.property_details->'steps'->'com_cow_location'->>'city',
            p.property_details->'steps'->'land_sale_location'->>'city',
            p.property_details->'steps'->'land_location'->>'city',
            p.property_details->'location'->>'city'
        )::TEXT as city,
        
        -- State (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'state',
            p.property_details->'steps'->'res_sale_location'->>'state',
            p.property_details->'steps'->'res_flat_location'->>'state',
            p.property_details->'steps'->'res_pg_location'->>'state',
            p.property_details->'steps'->'com_rent_location'->>'state',
            p.property_details->'steps'->'com_sale_location'->>'state',
            p.property_details->'steps'->'com_cow_location'->>'state',
            p.property_details->'steps'->'land_sale_location'->>'state',
            p.property_details->'steps'->'land_location'->>'state',
            p.property_details->'location'->>'state'
        )::TEXT as state,
        
        -- Area (works for all property types)
        COALESCE(
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'res_flat_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_flat_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'res_pg_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'com_rent_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'com_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_basic_details'->>'area'),
            safe_numeric(p.property_details->'basicDetails'->>'area')
        ) as area,
        
        prof.email::TEXT as owner_email,
        COALESCE(p.status, 'active')::TEXT as status,
        
        -- TYPE-SPECIFIC FIELDS (4 fields)
        -- Bedrooms (only for residential) - ENHANCED to include flatmates and PG
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    -- Extract from bhkType format (e.g., "2 BHK")
                    CASE 
                        WHEN p.property_details->'steps'->'res_rent_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_rent_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    CASE 
                        WHEN p.property_details->'steps'->'res_sale_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_sale_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    CASE 
                        WHEN p.property_details->'steps'->'res_flat_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_flat_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    CASE 
                        WHEN p.property_details->'basicDetails'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'basicDetails'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    -- Direct bedrooms fields
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'steps'->'res_flat_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'steps'->'res_pg_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'basicDetails'->>'bedrooms')::integer
                )
            ELSE NULL
        END as bedrooms,
        
        -- Bathrooms (only for residential) - ENHANCED to include flatmates and PG
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'steps'->'res_flat_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'steps'->'res_pg_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'basicDetails'->>'bathrooms')
                )
            ELSE NULL
        END as bathrooms,
        
        -- Area unit
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'areaUnit',
                    p.property_details->'steps'->'land_basic_details'->>'areaUnit',
                    'sq_ft'
                )
            ELSE 'sq_ft'
        END::TEXT as area_unit,
        
        -- Land type (only for land properties)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'landType',
                    p.property_details->'steps'->'land_basic_details'->>'landType',
                    p.property_details->'basicDetails'->>'landType',
                    'agricultural'
                )
            ELSE NULL
        END::TEXT as land_type,
        
        -- Primary image (ENHANCED - more comprehensive image extraction)
        COALESCE(
            -- Check imageFiles array first (iterate to find primary)
            CASE 
                WHEN p.property_details ? 'imageFiles' AND jsonb_array_length(p.property_details->'imageFiles') > 0 THEN
                    COALESCE(
                        -- Try to find primary image in array
                        (
                            SELECT (elem->>'fileName')
                            FROM jsonb_array_elements(p.property_details->'imageFiles') elem
                            WHERE (elem->>'isPrimary')::boolean = true
                            LIMIT 1
                        ),
                        -- If no primary found, use first image
                        (p.property_details->'imageFiles'->0)->>'fileName'
                    )
                ELSE NULL 
            END,
            -- Check alternative locations
            p.property_details->'steps'->'image_upload'->>'primaryImage',
            p.property_details->'steps'->'images'->>'primaryImage',
            p.property_details->'media'->'photos'->>'primaryImage',
            p.property_details->'images'->>'primary'
        )::TEXT as primary_image,
        
        -- COORDINATE FIELDS (NEW)
        extract_general_latitude(p.property_details) as latitude,
        extract_general_longitude(p.property_details) as longitude
        
    FROM properties_v2 p
    LEFT JOIN profiles prof ON p.owner_id = prof.id
    WHERE p.status IS DISTINCT FROM 'deleted'
    ORDER BY p.created_at DESC
    LIMIT p_limit;
    
END;


Schema: public | Name: admin_insert_property_image | Type: FUNCTION
  Returns: json | Specific Name: admin_insert_property_image_163088
  Definition: 
DECLARE
  v_user_id UUID;
  v_is_admin BOOLEAN;
  v_next_order INTEGER;
  v_result JSONB;
  v_image_id UUID;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  -- Check if user is admin
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = v_user_id 
    AND ar.role_type IN ('admin', 'super_admin', 'property_moderator')
  ) INTO v_is_admin;
  
  -- Only proceed if user is admin
  IF NOT v_is_admin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Permission denied'
    );
  END IF;
  
  -- Get next display order
  SELECT COALESCE(MAX(display_order), 0) + 1 
  FROM property_images 
  WHERE property_id = p_property_id 
  INTO v_next_order;
  
  -- Insert the image record
  INSERT INTO property_images (
    property_id,
    url,
    is_primary,
    display_order
  ) VALUES (
    p_property_id,
    p_url,
    p_is_primary,
    v_next_order
  )
  RETURNING id INTO v_image_id;
  
  -- If this is the primary image, clear other primary flags
  IF p_is_primary THEN
    UPDATE property_images
    SET is_primary = false
    WHERE property_id = p_property_id
    AND id != v_image_id;
  END IF;
  
  -- Return success with image details
  RETURN json_build_object(
    'success', true,
    'id', v_image_id,
    'url', p_url,
    'is_primary', p_is_primary,
    'display_order', v_next_order
  );
END;


Schema: public | Name: check_user_admin_status | Type: FUNCTION
  Returns: boolean | Specific Name: check_user_admin_status_163089
  Definition: 
DECLARE
  v_is_admin BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = user_id_param
    AND ar.role_type IN ('admin', 'super_admin', 'property_moderator')
  ) INTO v_is_admin;
  
  RETURN v_is_admin;
END;


Schema: public | Name: extract_primary_image | Type: FUNCTION
  Returns: text | Specific Name: extract_primary_image_198140
  Definition: 
    DECLARE
        image_item JSONB;
    BEGIN
        -- Check if imageFiles exists and is an array
        IF property_details ? 'imageFiles' AND jsonb_typeof(property_details->'imageFiles') = 'array' THEN
            -- Loop through imageFiles array to find the primary image
            FOR image_item IN SELECT jsonb_array_elements(property_details->'imageFiles')
            LOOP
                IF (image_item->>'isPrimary')::boolean = true THEN
                    RETURN image_item->>'fileName';
                END IF;
            END LOOP;
        END IF;
        
        -- Also check in steps for different flow types
        IF property_details ? 'steps' THEN
            -- Check in image upload sections
            IF property_details->'steps' ? 'image_upload' AND 
               property_details->'steps'->'image_upload' ? 'imageFiles' THEN
                FOR image_item IN SELECT jsonb_array_elements(property_details->'steps'->'image_upload'->'imageFiles')
                LOOP
                    IF (image_item->>'isPrimary')::boolean = true THEN
                        RETURN image_item->>'fileName';
                    END IF;
                END LOOP;
            END IF;
            
            -- Check in media sections
            IF property_details->'steps' ? 'media' AND 
               property_details->'steps'->'media' ? 'imageFiles' THEN
                FOR image_item IN SELECT jsonb_array_elements(property_details->'steps'->'media'->'imageFiles')
                LOOP
                    IF (image_item->>'isPrimary')::boolean = true THEN
                        RETURN image_item->>'fileName';
                    END IF;
                END LOOP;
            END IF;
        END IF;
        
        -- Return NULL if no primary image found
        RETURN NULL;
    END;
    

Schema: auth | Name: jwt | Type: FUNCTION
  Returns: jsonb | Specific Name: jwt_29655
  Definition: 
  select 
    coalesce(
        nullif(current_setting('request.jwt.claim', true), ''),
        nullif(current_setting('request.jwt.claims', true), '')
    )::jsonb


Schema: public | Name: admin_insert_property_image | Type: FUNCTION
  Returns: json | Specific Name: admin_insert_property_image_163136
  Definition: 
DECLARE
  v_user_id UUID;
  v_is_admin BOOLEAN;
  v_next_order INTEGER;
  v_image_id UUID;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  -- Check if user is admin
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = v_user_id 
    AND ar.role_type IN ('admin', 'super_admin', 'property_moderator')
  ) INTO v_is_admin;
  
  -- Only proceed if user is admin
  IF NOT v_is_admin THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Permission denied'
    );
  END IF;
  
  -- Get next display order if not provided
  IF p_display_order IS NULL THEN
    SELECT COALESCE(MAX(display_order), 0) + 1 
    FROM property_images 
    WHERE property_id = p_property_id 
    INTO v_next_order;
  ELSE
    v_next_order := p_display_order;
  END IF;
  
  -- Generate UUID for new image
  v_image_id := gen_random_uuid();
  
  -- Insert the image record
  INSERT INTO property_images (
    id,
    property_id,
    url,
    is_primary,
    display_order,
    created_at
  ) VALUES (
    v_image_id,
    p_property_id,
    p_url,
    p_is_primary,
    v_next_order,
    NOW()
  );
  
  -- If this is the primary image, clear other primary flags
  IF p_is_primary THEN
    UPDATE property_images
    SET is_primary = false
    WHERE property_id = p_property_id
    AND id != v_image_id;
  END IF;
  
  -- Return success with image details
  RETURN json_build_object(
    'success', true,
    'id', v_image_id,
    'url', p_url,
    'is_primary', p_is_primary,
    'display_order', v_next_order
  );
END;


Schema: public | Name: admin_delete_property_image | Type: FUNCTION
  Returns: boolean | Specific Name: admin_delete_property_image_163137
  Definition: 
DECLARE
  v_user_id UUID;
  v_is_admin BOOLEAN;
  v_deleted BOOLEAN;
BEGIN
  -- Get current user ID
  v_user_id := auth.uid();
  
  -- Check if user is admin
  SELECT EXISTS (
    SELECT 1
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = v_user_id 
    AND ar.role_type IN ('admin', 'super_admin', 'property_moderator')
  ) INTO v_is_admin;
  
  -- Only proceed if user is admin
  IF NOT v_is_admin THEN
    RETURN false;
  END IF;
  
  -- Delete the image
  DELETE FROM property_images
  WHERE id = image_id_param;
  
  GET DIAGNOSTICS v_deleted = ROW_COUNT;
  
  RETURN v_deleted > 0;
END;


Schema: public | Name: find_nearby_properties | Type: FUNCTION
  Returns: record | Specific Name: find_nearby_properties_187192
  Definition: 
DECLARE
    v_lat_delta DECIMAL(10,8);
    v_lng_delta DECIMAL(11,8);
BEGIN
    -- Validate input parameters
    IF p_latitude IS NULL OR p_longitude IS NULL THEN
        RAISE EXCEPTION 'Latitude and longitude cannot be null';
    END IF;
    
    IF p_latitude < -90 OR p_latitude > 90 OR p_longitude < -180 OR p_longitude > 180 THEN
        RAISE EXCEPTION 'Invalid coordinate values (latitude: %, longitude: %)', p_latitude, p_longitude;
    END IF;
    
    -- Calculate bounding box (approximate)
    -- 1 degree ≈ 111 km at equator
    v_lat_delta := p_radius_km / 111.0;
    v_lng_delta := p_radius_km / (111.0 * cos(radians(p_latitude)));
    
    -- Use a subquery approach to avoid GROUP BY issues
    RETURN QUERY
    SELECT 
        coords_with_distance.property_id,
        coords_with_distance.latitude,
        coords_with_distance.longitude,
        coords_with_distance.distance_km,
        coords_with_distance.address,
        coords_with_distance.city,
        coords_with_distance.state
    FROM (
        SELECT 
            pc.property_id,
            pc.latitude,
            pc.longitude,
            CAST(
                6371 * acos(
                    LEAST(1.0, GREATEST(-1.0,
                        cos(radians(p_latitude)) 
                        * cos(radians(pc.latitude)) 
                        * cos(radians(pc.longitude) - radians(p_longitude)) 
                        + sin(radians(p_latitude)) 
                        * sin(radians(pc.latitude))
                    ))
                ) AS DECIMAL(10, 3)
            ) AS distance_km,
            pc.address,
            pc.city,
            pc.state
        FROM public.property_coordinates pc
        WHERE 
            -- Bounding box filter (fast)
            pc.latitude BETWEEN (p_latitude - v_lat_delta) AND (p_latitude + v_lat_delta)
            AND pc.longitude BETWEEN (p_longitude - v_lng_delta) AND (p_longitude + v_lng_delta)
            -- Exclude specific property if provided
            AND (p_exclude_property_id IS NULL OR pc.property_id != p_exclude_property_id)
    ) AS coords_with_distance
    WHERE coords_with_distance.distance_km <= p_radius_km
    ORDER BY coords_with_distance.distance_km
    LIMIT p_limit;
    
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Error in find_nearby_properties: %', SQLERRM;
END;


Schema: public | Name: verify_admin_status | Type: FUNCTION
  Returns: record | Specific Name: verify_admin_status_60470
  Definition: 
BEGIN
    RETURN QUERY
    SELECT 
        TRUE as is_admin,
        ar.role_type
    FROM admin_users au
    JOIN admin_roles ar ON au.role_id = ar.id
    JOIN auth.users u ON au.user_id = u.id
    WHERE u.email = user_email;
END;


Schema: public | Name: find_similar_properties | Type: FUNCTION
  Returns: record | Specific Name: find_similar_properties_207416
  Definition: 
DECLARE
    v_target_property RECORD;
    v_target_flow_type TEXT;
    v_target_property_type TEXT;
BEGIN
    -- Validate limit parameter
    IF p_limit IS NULL OR p_limit <= 0 OR p_limit > 50 THEN
        p_limit := 10;
    END IF;
    
    IF p_min_similarity_score IS NULL OR p_min_similarity_score < 0 THEN
        p_min_similarity_score := 0.3;
    END IF;

    -- Get target property details
    SELECT 
        p.id,
        p.property_details,
        -- Determine property type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN 'residential'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'commercial_%' THEN 'commercial'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN 'land'
            ELSE 'residential'
        END as target_property_type,
        COALESCE(
            p.property_details->'flow'->>'flowType',
            p.property_details->>'flowType',
            'residential_rent'
        ) as target_flow_type
    INTO v_target_property
    FROM properties_v2 p
    WHERE p.id = p_property_id AND p.status IS DISTINCT FROM 'deleted';

    -- If target property not found, return empty result
    IF v_target_property.id IS NULL THEN
        RETURN;
    END IF;

    v_target_flow_type := v_target_property.target_flow_type;
    v_target_property_type := v_target_property.target_property_type;

    -- Return similar properties based on property type
    IF v_target_property_type = 'residential' THEN
        RETURN QUERY
        SELECT * FROM find_similar_residential_properties(p_property_id, v_target_property.property_details, p_limit, p_min_similarity_score);
    ELSIF v_target_property_type = 'commercial' THEN
        RETURN QUERY
        SELECT * FROM find_similar_commercial_properties(p_property_id, v_target_property.property_details, p_limit, p_min_similarity_score);
    ELSIF v_target_property_type = 'land' THEN
        RETURN QUERY
        SELECT * FROM find_similar_land_properties(p_property_id, v_target_property.property_details, p_limit, p_min_similarity_score);
    END IF;
END;


Schema: public | Name: find_similar_residential_properties | Type: FUNCTION
  Returns: record | Specific Name: find_similar_residential_properties_207417
  Definition: 
DECLARE
    v_target_flow_type TEXT;
    v_target_city TEXT;
    v_target_state TEXT;
    v_target_price NUMERIC;
    v_target_bedrooms INTEGER;
    v_target_bathrooms NUMERIC;
    v_target_area NUMERIC;
BEGIN
    -- Extract target property attributes using existing helper functions
    v_target_flow_type := extract_residential_flow_type(p_target_details);
    v_target_city := extract_residential_city(p_target_details);
    v_target_state := extract_residential_state(p_target_details);
    v_target_price := extract_residential_price(p_target_details);
    v_target_bedrooms := extract_residential_bedrooms(p_target_details);
    v_target_bathrooms := extract_residential_bathrooms(p_target_details);
    v_target_area := extract_residential_area(p_target_details);

    RETURN QUERY
    WITH similarity_calc AS (
        SELECT 
            p.*,
            prof.email as owner_email,
            -- Calculate similarity score (0-1 scale)
            (
                -- Flow type match (weight: 25%)
                CASE WHEN extract_residential_flow_type(p.property_details) = v_target_flow_type THEN 0.25 ELSE 0 END +
                
                -- Location match (weight: 20%)
                CASE 
                    WHEN extract_residential_city(p.property_details) = v_target_city THEN 0.20
                    WHEN extract_residential_state(p.property_details) = v_target_state THEN 0.10
                    ELSE 0 
                END +
                
                -- Price similarity (weight: 20%)
                CASE 
                    WHEN v_target_price IS NOT NULL AND extract_residential_price(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.20 - (0.20 * ABS(extract_residential_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1)))
                    ELSE 0.10 -- Small bonus if both prices are null
                END +
                
                -- Bedrooms match (weight: 15%)
                CASE 
                    WHEN v_target_bedrooms IS NOT NULL AND extract_residential_bedrooms(p.property_details) IS NOT NULL THEN
                        CASE 
                            WHEN extract_residential_bedrooms(p.property_details) = v_target_bedrooms THEN 0.15
                            WHEN ABS(extract_residential_bedrooms(p.property_details) - v_target_bedrooms) = 1 THEN 0.10
                            WHEN ABS(extract_residential_bedrooms(p.property_details) - v_target_bedrooms) = 2 THEN 0.05
                            ELSE 0
                        END
                    ELSE 0.05 -- Small bonus if both bedrooms are null
                END +
                
                -- Area similarity (weight: 10%)
                CASE 
                    WHEN v_target_area IS NOT NULL AND extract_residential_area(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.10 - (0.10 * ABS(extract_residential_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1)))
                    ELSE 0.05 -- Small bonus if both areas are null
                END +
                
                -- Bathrooms similarity (weight: 10%)
                CASE 
                    WHEN v_target_bathrooms IS NOT NULL AND extract_residential_bathrooms(p.property_details) IS NOT NULL THEN
                        CASE 
                            WHEN extract_residential_bathrooms(p.property_details) = v_target_bathrooms THEN 0.10
                            WHEN ABS(extract_residential_bathrooms(p.property_details) - v_target_bathrooms) <= 1 THEN 0.05
                            ELSE 0
                        END
                    ELSE 0.05 -- Small bonus if both bathrooms are null
                END
            ) as calculated_similarity_score,
            
            -- Store similarity factors for debugging
            jsonb_build_object(
                'flow_type_match', extract_residential_flow_type(p.property_details) = v_target_flow_type,
                'city_match', extract_residential_city(p.property_details) = v_target_city,
                'state_match', extract_residential_state(p.property_details) = v_target_state,
                'price_diff_percent', 
                    CASE 
                        WHEN v_target_price IS NOT NULL AND extract_residential_price(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_residential_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END,
                'bedrooms_diff', 
                    CASE 
                        WHEN v_target_bedrooms IS NOT NULL AND extract_residential_bedrooms(p.property_details) IS NOT NULL THEN
                            extract_residential_bedrooms(p.property_details) - v_target_bedrooms
                        ELSE NULL 
                    END,
                'area_diff_percent',
                    CASE 
                        WHEN v_target_area IS NOT NULL AND extract_residential_area(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_residential_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END
            ) as similarity_factors
        FROM properties_v2 p
        LEFT JOIN profiles prof ON p.owner_id = prof.id
        WHERE p.status IS DISTINCT FROM 'deleted'
          AND p.id != p_property_id  -- Exclude the target property itself
          AND extract_residential_flow_type(p.property_details) LIKE 'residential_%'
          -- Basic filters for performance
          AND (v_target_state IS NULL OR extract_residential_state(p.property_details) = v_target_state)
          AND (v_target_price IS NULL OR extract_residential_price(p.property_details) BETWEEN v_target_price * 0.5 AND v_target_price * 2.0)
    )
    SELECT 
        sc.id,
        sc.owner_id,
        sc.created_at,
        sc.updated_at,
        'residential'::TEXT as property_type,
        extract_residential_flow_type(sc.property_details)::TEXT as flow_type,
        flow_type_to_subtype(extract_residential_flow_type(sc.property_details))::TEXT as subtype,
        extract_residential_title(sc.property_details)::TEXT as title,
        extract_residential_price(sc.property_details) as price,
        extract_residential_city(sc.property_details)::TEXT as city,
        extract_residential_state(sc.property_details)::TEXT as state,
        extract_residential_area(sc.property_details) as area,
        sc.owner_email::TEXT,
        COALESCE(sc.status, 'active')::TEXT as status,
        extract_residential_bedrooms(sc.property_details) as bedrooms,
        extract_residential_bathrooms(sc.property_details) as bathrooms,
        'sq_ft'::TEXT as area_unit,
        NULL::TEXT as land_type,
        extract_residential_primary_image(sc.property_details)::TEXT as primary_image,
        ROUND(sc.calculated_similarity_score::NUMERIC, 3) as similarity_score,
        sc.similarity_factors,
        -- COORDINATE FIELDS (NEW)
        extract_residential_latitude(sc.property_details) as latitude,
        extract_residential_longitude(sc.property_details) as longitude
    FROM similarity_calc sc
    WHERE sc.calculated_similarity_score >= p_min_similarity_score
    ORDER BY sc.calculated_similarity_score DESC, sc.created_at DESC
    LIMIT p_limit;
END;


Schema: public | Name: delete_property_image | Type: FUNCTION
  Returns: boolean | Specific Name: delete_property_image_80954
  Definition: 
DECLARE
  is_moderator boolean;
  image_exists boolean;
BEGIN
  -- Check if the user is a moderator
  SELECT EXISTS (
    SELECT 1
    FROM public.admin_users au
    JOIN public.admin_roles ar ON au.role_id = ar.id
    WHERE au.user_id = auth.uid() AND ar.role_type = 'property_moderator'
  ) INTO is_moderator;
  
  -- Check if image exists
  SELECT EXISTS (
    SELECT 1 FROM public.property_images WHERE id = image_id
  ) INTO image_exists;
  
  -- Only proceed if user is a moderator and image exists
  IF is_moderator AND image_exists THEN
    -- Delete the image
    DELETE FROM public.property_images WHERE id = image_id;
    RETURN true;
  ELSE
    RETURN false;
  END IF;
END;


Schema: public | Name: find_similar_commercial_properties | Type: FUNCTION
  Returns: record | Specific Name: find_similar_commercial_properties_207419
  Definition: 
DECLARE
    v_target_flow_type TEXT;
    v_target_city TEXT;
    v_target_state TEXT;
    v_target_price NUMERIC;
    v_target_area NUMERIC;
    v_target_property_type TEXT;
BEGIN
    -- Extract target property attributes using existing helper functions
    v_target_flow_type := extract_commercial_flow_type(p_target_details);
    v_target_city := extract_commercial_city(p_target_details);
    v_target_state := extract_commercial_state(p_target_details);
    v_target_price := extract_commercial_price(p_target_details);
    v_target_area := extract_commercial_area(p_target_details);
    v_target_property_type := extract_commercial_property_type(p_target_details);

    RETURN QUERY
    WITH similarity_calc AS (
        SELECT 
            p.*,
            prof.email as owner_email,
            -- Calculate similarity score (0-1 scale)
            (
                -- Flow type match (weight: 30%)
                CASE WHEN extract_commercial_flow_type(p.property_details) = v_target_flow_type THEN 0.30 ELSE 0 END +
                
                -- Location match (weight: 25%)
                CASE 
                    WHEN extract_commercial_city(p.property_details) = v_target_city THEN 0.25
                    WHEN extract_commercial_state(p.property_details) = v_target_state THEN 0.15
                    ELSE 0 
                END +
                
                -- Price similarity (weight: 25%)
                CASE 
                    WHEN v_target_price IS NOT NULL AND extract_commercial_price(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.25 - (0.25 * ABS(extract_commercial_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1)))
                    ELSE 0.10 -- Small bonus if both prices are null
                END +
                
                -- Area similarity (weight: 15%)
                CASE 
                    WHEN v_target_area IS NOT NULL AND extract_commercial_area(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.15 - (0.15 * ABS(extract_commercial_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1)))
                    ELSE 0.05 -- Small bonus if both areas are null
                END +
                
                -- Property type match (weight: 5%)
                CASE WHEN extract_commercial_property_type(p.property_details) = v_target_property_type THEN 0.05 ELSE 0 END
            ) as calculated_similarity_score,
            
            -- Store similarity factors for debugging
            jsonb_build_object(
                'flow_type_match', extract_commercial_flow_type(p.property_details) = v_target_flow_type,
                'city_match', extract_commercial_city(p.property_details) = v_target_city,
                'state_match', extract_commercial_state(p.property_details) = v_target_state,
                'property_type_match', extract_commercial_property_type(p.property_details) = v_target_property_type,
                'price_diff_percent', 
                    CASE 
                        WHEN v_target_price IS NOT NULL AND extract_commercial_price(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_commercial_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END,
                'area_diff_percent',
                    CASE 
                        WHEN v_target_area IS NOT NULL AND extract_commercial_area(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_commercial_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END
            ) as similarity_factors
        FROM properties_v2 p
        LEFT JOIN profiles prof ON p.owner_id = prof.id
        WHERE p.status IS DISTINCT FROM 'deleted'
          AND p.id != p_property_id  -- Exclude the target property itself
          AND extract_commercial_flow_type(p.property_details) IN ('commercial_rent', 'commercial_sale', 'commercial_coworking')
          -- Basic filters for performance
          AND (v_target_state IS NULL OR extract_commercial_state(p.property_details) = v_target_state)
          AND (v_target_price IS NULL OR extract_commercial_price(p.property_details) BETWEEN v_target_price * 0.5 AND v_target_price * 2.0)
    )
    SELECT 
        sc.id,
        sc.owner_id,
        sc.created_at,
        sc.updated_at,
        'commercial'::TEXT as property_type,
        extract_commercial_flow_type(sc.property_details)::TEXT as flow_type,
        commercial_flow_type_to_subtype(extract_commercial_flow_type(sc.property_details))::TEXT as subtype,
        extract_commercial_title(sc.property_details)::TEXT as title,
        extract_commercial_price(sc.property_details) as price,
        extract_commercial_city(sc.property_details)::TEXT as city,
        extract_commercial_state(sc.property_details)::TEXT as state,
        extract_commercial_area(sc.property_details) as area,
        sc.owner_email::TEXT,
        COALESCE(sc.status, 'active')::TEXT as status,
        NULL::INTEGER as bedrooms,
        NULL::NUMERIC as bathrooms,
        'sq_ft'::TEXT as area_unit,
        NULL::TEXT as land_type,
        extract_commercial_primary_image(sc.property_details)::TEXT as primary_image,
        ROUND(sc.calculated_similarity_score::NUMERIC, 3) as similarity_score,
        sc.similarity_factors,
        -- COORDINATE FIELDS (NEW)
        extract_commercial_latitude(sc.property_details) as latitude,
        extract_commercial_longitude(sc.property_details) as longitude
    FROM similarity_calc sc
    WHERE sc.calculated_similarity_score >= p_min_similarity_score
    ORDER BY sc.calculated_similarity_score DESC, sc.created_at DESC
    LIMIT p_limit;
END;


Schema: public | Name: find_similar_land_properties | Type: FUNCTION
  Returns: record | Specific Name: find_similar_land_properties_207421
  Definition: 
DECLARE
    v_target_flow_type TEXT;
    v_target_city TEXT;
    v_target_state TEXT;
    v_target_price NUMERIC;
    v_target_area NUMERIC;
    v_target_land_type TEXT;
    v_target_area_unit TEXT;
BEGIN
    -- Extract target property attributes using existing helper functions
    v_target_flow_type := extract_land_flow_type(p_target_details);
    v_target_city := extract_land_city(p_target_details);
    v_target_state := extract_land_state(p_target_details);
    v_target_price := extract_land_price(p_target_details);
    v_target_area := extract_land_area(p_target_details);
    v_target_land_type := extract_land_type(p_target_details);
    v_target_area_unit := extract_land_area_unit(p_target_details);

    RETURN QUERY
    WITH similarity_calc AS (
        SELECT 
            p.*,
            prof.email as owner_email,
            -- Calculate similarity score (0-1 scale)
            (
                -- Flow type match (weight: 25%)
                CASE WHEN extract_land_flow_type(p.property_details) = v_target_flow_type THEN 0.25 ELSE 0 END +
                
                -- Location match (weight: 25%)
                CASE 
                    WHEN extract_land_city(p.property_details) = v_target_city THEN 0.25
                    WHEN extract_land_state(p.property_details) = v_target_state THEN 0.15
                    ELSE 0 
                END +
                
                -- Price similarity (weight: 25%)
                CASE 
                    WHEN v_target_price IS NOT NULL AND extract_land_price(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.25 - (0.25 * ABS(extract_land_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1)))
                    ELSE 0.10 -- Small bonus if both prices are null
                END +
                
                -- Area similarity (weight: 15%)
                CASE 
                    WHEN v_target_area IS NOT NULL AND extract_land_area(p.property_details) IS NOT NULL THEN
                        GREATEST(0, 0.15 - (0.15 * ABS(extract_land_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1)))
                    ELSE 0.05 -- Small bonus if both areas are null
                END +
                
                -- Land type match (weight: 10%)
                CASE WHEN extract_land_type(p.property_details) = v_target_land_type THEN 0.10 ELSE 0 END
            ) as calculated_similarity_score,
            
            -- Store similarity factors for debugging
            jsonb_build_object(
                'flow_type_match', extract_land_flow_type(p.property_details) = v_target_flow_type,
                'city_match', extract_land_city(p.property_details) = v_target_city,
                'state_match', extract_land_state(p.property_details) = v_target_state,
                'land_type_match', extract_land_type(p.property_details) = v_target_land_type,
                'price_diff_percent', 
                    CASE 
                        WHEN v_target_price IS NOT NULL AND extract_land_price(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_land_price(p.property_details) - v_target_price) / GREATEST(v_target_price, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END,
                'area_diff_percent',
                    CASE 
                        WHEN v_target_area IS NOT NULL AND extract_land_area(p.property_details) IS NOT NULL THEN
                            ROUND((ABS(extract_land_area(p.property_details) - v_target_area) / GREATEST(v_target_area, 1) * 100)::NUMERIC, 2)
                        ELSE NULL 
                    END
            ) as similarity_factors
        FROM properties_v2 p
        LEFT JOIN profiles prof ON p.owner_id = prof.id
        WHERE p.status IS DISTINCT FROM 'deleted'
          AND p.id != p_property_id  -- Exclude the target property itself
          AND (extract_land_flow_type(p.property_details) = 'land_sale' OR extract_land_flow_type(p.property_details) LIKE '%land%')
          -- Basic filters for performance
          AND (v_target_state IS NULL OR extract_land_state(p.property_details) = v_target_state)
          AND (v_target_price IS NULL OR extract_land_price(p.property_details) BETWEEN v_target_price * 0.5 AND v_target_price * 2.0)
    )
    SELECT 
        sc.id,
        sc.owner_id,
        sc.created_at,
        sc.updated_at,
        'land'::TEXT as property_type,
        extract_land_flow_type(sc.property_details)::TEXT as flow_type,
        land_flow_type_to_subtype(extract_land_flow_type(sc.property_details))::TEXT as subtype,
        extract_land_title(sc.property_details)::TEXT as title,
        extract_land_price(sc.property_details) as price,
        extract_land_city(sc.property_details)::TEXT as city,
        extract_land_state(sc.property_details)::TEXT as state,
        extract_land_area(sc.property_details) as area,
        sc.owner_email::TEXT,
        COALESCE(sc.status, 'active')::TEXT as status,
        NULL::INTEGER as bedrooms,
        NULL::NUMERIC as bathrooms,
        extract_land_area_unit(sc.property_details)::TEXT as area_unit,
        extract_land_type(sc.property_details)::TEXT as land_type,
        extract_land_primary_image(sc.property_details)::TEXT as primary_image,
        ROUND(sc.calculated_similarity_score::NUMERIC, 3) as similarity_score,
        sc.similarity_factors,
        -- COORDINATE FIELDS (NEW)
        extract_land_latitude(sc.property_details) as latitude,
        extract_land_longitude(sc.property_details) as longitude
    FROM similarity_calc sc
    WHERE sc.calculated_similarity_score >= p_min_similarity_score
    ORDER BY sc.calculated_similarity_score DESC, sc.created_at DESC
    LIMIT p_limit;
END;


Schema: public | Name: direct_update_coordinates | Type: FUNCTION
  Returns: jsonb | Specific Name: direct_update_coordinates_122884
  Definition: 
DECLARE
  result JSONB;
BEGIN
  UPDATE properties
  SET property_details = property_details || 
      jsonb_build_object('coordinates', jsonb_build_object('lat', lat_value, 'lng', lng_value))
  WHERE id = property_id
  RETURNING property_details INTO result;
  
  RETURN result;
END;


Schema: public | Name: search_property_by_code | Type: FUNCTION
  Returns: record | Specific Name: search_property_by_code_207444
  Definition: 
DECLARE
    v_total_count BIGINT;
BEGIN
    -- Validate input
    IF p_code IS NULL OR trim(p_code) = '' THEN
        RAISE EXCEPTION 'Property code cannot be null or empty';
    END IF;

    -- Get total count of matching properties
    SELECT COUNT(*) INTO v_total_count
    FROM properties_v2 p
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND p.property_details->'meta'->>'code' = p_code;

    -- Return results for matching properties
    RETURN QUERY
    SELECT 
        -- MANDATORY CORE (8 fields)
        p.id,
        p.owner_id,
        p.created_at,
        p.updated_at,
        
        -- Determine property type based on flow_type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN 'residential'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'commercial_%' THEN 'commercial'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN 'land'
            ELSE 'residential'
        END::TEXT as property_type,
        
        -- Flow type
        COALESCE(
            p.property_details->'flow'->>'flowType',
            p.property_details->>'flowType',
            'residential_rent'
        )::TEXT as flow_type,
        
        -- Subtype based on flow type
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_flatmates' THEN 'flatmates'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'residential_pghostel' THEN 'pghostel'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_rent' THEN 'rent'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_sale' THEN 'sale'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'commercial_coworking' THEN 'coworking'
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) = 'land_sale' THEN 'sale'
            ELSE 'rent'
        END::TEXT as subtype,
        
        v_total_count as total_count,
        
        -- COMMON FIELDS (7 fields)
        -- Title (works for all property types)
        COALESCE(
            p.property_details->'flow'->>'title',
            p.property_details->'steps'->'res_rent_basic_details'->>'title',
            p.property_details->'steps'->'res_sale_basic_details'->>'title',
            p.property_details->'steps'->'res_flat_basic_details'->>'title',
            p.property_details->'steps'->'res_pg_basic_details'->>'title',
            p.property_details->'steps'->'com_rent_basic_details'->>'title',
            p.property_details->'steps'->'com_sale_basic_details'->>'title',
            p.property_details->'steps'->'com_cow_basic_details'->>'title',
            p.property_details->'steps'->'land_sale_basic_details'->>'title',
            p.property_details->'steps'->'land_basic_details'->>'title',
            p.property_details->'basicDetails'->>'title',
            'Property'
        )::TEXT as title,
        
        -- Price (works for all property types)
        COALESCE(
            safe_numeric(p.property_details->'flow'->>'price'),
            safe_numeric(p.property_details->'steps'->'res_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'res_sale_sale_details'->>'expectedPrice'),
            safe_numeric(p.property_details->'steps'->'com_rent_rental'->>'rentAmount'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'salePrice'),
            safe_numeric(p.property_details->'steps'->'com_sale_sale_details'->>'expectedPrice'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'price'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'salePrice'),
            safe_numeric(p.property_details->>'price')
        ) as price,
        
        -- City (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'city',
            p.property_details->'steps'->'res_sale_location'->>'city',
            p.property_details->'steps'->'res_flat_location'->>'city',
            p.property_details->'steps'->'res_pg_location'->>'city',
            p.property_details->'steps'->'com_rent_location'->>'city',
            p.property_details->'steps'->'com_sale_location'->>'city',
            p.property_details->'steps'->'com_cow_location'->>'city',
            p.property_details->'steps'->'land_sale_location'->>'city',
            p.property_details->'steps'->'land_location'->>'city',
            p.property_details->'location'->>'city'
        )::TEXT as city,
        
        -- State (works for all property types)
        COALESCE(
            p.property_details->'steps'->'res_rent_location'->>'state',
            p.property_details->'steps'->'res_sale_location'->>'state',
            p.property_details->'steps'->'res_flat_location'->>'state',
            p.property_details->'steps'->'res_pg_location'->>'state',
            p.property_details->'steps'->'com_rent_location'->>'state',
            p.property_details->'steps'->'com_sale_location'->>'state',
            p.property_details->'steps'->'com_cow_location'->>'state',
            p.property_details->'steps'->'land_sale_location'->>'state',
            p.property_details->'steps'->'land_location'->>'state',
            p.property_details->'location'->>'state'
        )::TEXT as state,
        
        -- Area (works for all property types)
        COALESCE(
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'squareFootage'),
            safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'builtUpArea'),
            safe_numeric(p.property_details->'steps'->'com_rent_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'com_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_sale_basic_details'->>'area'),
            safe_numeric(p.property_details->'steps'->'land_basic_details'->>'area'),
            safe_numeric(p.property_details->'basicDetails'->>'area')
        ) as area,
        
        prof.email::TEXT as owner_email,
        COALESCE(p.status, 'active')::TEXT as status,
        
        -- TYPE-SPECIFIC FIELDS (4 fields)
        -- Bedrooms (only for residential)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    -- Extract from bhkType format (e.g., "2 BHK")
                    CASE 
                        WHEN p.property_details->'steps'->'res_rent_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_rent_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    CASE 
                        WHEN p.property_details->'steps'->'res_sale_basic_details'->>'bhkType' ~ '^[0-9]+' 
                        THEN (regexp_match(p.property_details->'steps'->'res_sale_basic_details'->>'bhkType', '^([0-9]+)'))[1]::integer
                        ELSE NULL 
                    END,
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bedrooms')::integer,
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bedrooms')::integer
                )
            ELSE NULL
        END as bedrooms,
        
        -- Bathrooms (only for residential)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'residential_%' THEN
                COALESCE(
                    safe_numeric(p.property_details->'steps'->'res_rent_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'steps'->'res_sale_basic_details'->>'bathrooms'),
                    safe_numeric(p.property_details->'basicDetails'->>'bathrooms')
                )
            ELSE NULL
        END as bathrooms,
        
        -- Area unit
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'areaUnit',
                    p.property_details->'steps'->'land_basic_details'->>'areaUnit',
                    'sq_ft'
                )
            ELSE 'sq_ft'
        END::TEXT as area_unit,
        
        -- Land type (only for land properties)
        CASE 
            WHEN COALESCE(
                p.property_details->'flow'->>'flowType',
                p.property_details->>'flowType',
                'residential_rent'
            ) LIKE 'land_%' THEN
                COALESCE(
                    p.property_details->'steps'->'land_sale_basic_details'->>'landType',
                    p.property_details->'steps'->'land_basic_details'->>'landType',
                    p.property_details->'basicDetails'->>'landType',
                    'agricultural'
                )
            ELSE NULL
        END::TEXT as land_type,
        
        -- Primary image (works for all property types)
        COALESCE(
            -- Check imageFiles array first
            CASE 
                WHEN p.property_details ? 'imageFiles' AND jsonb_array_length(p.property_details->'imageFiles') > 0 THEN
                    (p.property_details->'imageFiles'->0)->>'fileName'
                ELSE NULL 
            END,
            -- Check alternative locations
            p.property_details->'steps'->'image_upload'->>'primaryImage',
            p.property_details->'steps'->'images'->>'primaryImage',
            p.property_details->'media'->'photos'->>'primaryImage',
            p.property_details->'images'->>'primary'
        )::TEXT as primary_image,
        
        -- Property code from meta
        p.property_details->'meta'->>'code'::TEXT as code,
        
        -- COORDINATE FIELDS (NEW)
        extract_general_latitude(p.property_details) as latitude,
        extract_general_longitude(p.property_details) as longitude
        
    FROM properties_v2 p
    LEFT JOIN profiles prof ON p.owner_id = prof.id
    WHERE p.status IS DISTINCT FROM 'deleted'
      AND p.property_details->'meta'->>'code' = p_code
    ORDER BY p.created_at DESC;
    
END;


Schema: public | Name: search_property_by_code_insensitive | Type: FUNCTION
  Returns: record | Specific Name: search_property_by_code_insensitive_207446
  Definition: 
BEGIN
    -- Validate input
    IF p_code IS NULL OR trim(p_code) = '' THEN
        RAISE EXCEPTION 'Property code cannot be null or empty';
    END IF;

    -- Call the main function with uppercase code for case-insensitive search
    RETURN QUERY
    SELECT * FROM search_property_by_code(UPPER(trim(p_code)));
    
END;


Schema: public | Name: emergency_coordinate_update | Type: FUNCTION
  Returns: boolean | Specific Name: emergency_coordinate_update_122906
  Definition: 
DECLARE
  success BOOLEAN;
BEGIN
  -- Try different update approaches
  
  -- Approach 1: Full replacement approach
  UPDATE properties
  SET property_details = 
    CASE 
      WHEN property_details IS NULL THEN 
        jsonb_build_object('coordinates', jsonb_build_object('lat', p_lat, 'lng', p_lng))
      ELSE
        property_details || jsonb_build_object('coordinates', jsonb_build_object('lat', p_lat, 'lng', p_lng))
    END
  WHERE id = p_id;
  
  -- Check if update succeeded
  SELECT EXISTS (
    SELECT 1 FROM properties 
    WHERE id = p_id 
    AND property_details->'coordinates'->>'lat' IS NOT NULL
  ) INTO success;
  
  RETURN success;
END;


Schema: public | Name: admin_set_password | Type: FUNCTION
  Returns: boolean | Specific Name: admin_set_password_80596
  Definition: 
DECLARE
  v_user_id uuid;
BEGIN
  -- Get user ID
  SELECT id INTO v_user_id
  FROM auth.users
  WHERE email = user_email;
  
  IF v_user_id IS NULL THEN
    RETURN false;
  END IF;
  
  -- Directly update password
  UPDATE auth.users
  SET 
    encrypted_password = crypt(new_password, gen_salt('bf')),
    updated_at = now()
  WHERE id = v_user_id;
  
  RETURN true;
END;


Schema: public | Name: matches_residential_subtype | Type: FUNCTION
  Returns: boolean | Specific Name: matches_residential_subtype_198633
  Definition: 
DECLARE
   flow_type TEXT;
BEGIN
   IF p_subtype IS NULL THEN
       RETURN TRUE;
   END IF;
   
   flow_type := extract_residential_flow_type(property_details);
   
   RETURN CASE 
       WHEN p_subtype = 'rent' THEN flow_type = 'residential_rent'
       WHEN p_subtype = 'sale' THEN flow_type = 'residential_sale'
       WHEN p_subtype = 'flatmates' THEN flow_type = 'residential_flatmates'
       WHEN p_subtype = 'pghostel' THEN flow_type = 'residential_pghostel'
       ELSE TRUE
   END;
END;


Schema: public | Name: extract_residential_flow_type | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_flow_type_198631
  Definition: 
BEGIN
   RETURN COALESCE(
       property_details->'flow'->>'flowType',
       property_details->>'flowType',
       'residential_rent'
   );
END;


Schema: public | Name: flow_type_to_subtype | Type: FUNCTION
  Returns: text | Specific Name: flow_type_to_subtype_198632
  Definition: 
BEGIN
   RETURN CASE 
       WHEN flow_type = 'residential_rent' THEN 'rent'
       WHEN flow_type = 'residential_sale' THEN 'sale'
       WHEN flow_type = 'residential_flatmates' THEN 'flatmates'
       WHEN flow_type = 'residential_pghostel' THEN 'pghostel'
       ELSE 'rent'
   END;
END;


Schema: public | Name: extract_commercial_flow_type | Type: FUNCTION
  Returns: text | Specific Name: extract_commercial_flow_type_198715
  Definition: 
BEGIN
    RETURN COALESCE(
        property_details->'flow'->>'flowType',
        property_details->>'flowType',
        property_details->>'flow_type',
        property_details->'meta'->>'flow_type',
        'commercial_rent'
    );
END;


Schema: public | Name: handle_new_user | Type: FUNCTION
  Returns: trigger | Specific Name: handle_new_user_60596
  Definition: 
BEGIN
    IF NEW.raw_user_meta_data->>'is_admin' = 'true' THEN
        INSERT INTO public.admin_users (user_id, email, is_active, registration_date)
        VALUES (NEW.id, NEW.email, false, CURRENT_TIMESTAMP);
    END IF;
    RETURN NEW;
END;


Schema: public | Name: extract_residential_property_type | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_property_type_198656
  Definition: 
BEGIN
   RETURN COALESCE(
       property_details->'steps'->'res_rent_basic_details'->>'propertyType',
       property_details->'steps'->'res_sale_basic_details'->>'propertyType',
       property_details->'steps'->'res_flat_basic_details'->>'propertyType',
       property_details->'steps'->'res_pg_basic_details'->>'propertyType',
       property_details->'basicDetails'->>'propertyType'
   );
END;


Schema: public | Name: extract_residential_title | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_title_198628
  Definition: 
BEGIN
   RETURN COALESCE(
       property_details->'flow'->>'title',
       property_details->'steps'->'res_rent_basic_details'->>'title',
       property_details->'steps'->'res_sale_basic_details'->>'title',
       property_details->'steps'->'res_flat_basic_details'->>'title',
       property_details->'steps'->'res_pg_basic_details'->>'title',
       property_details->'basicDetails'->>'title',
       'Property'
   );
END;


Schema: public | Name: extract_residential_city | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_city_198629
  Definition: 
BEGIN
   RETURN COALESCE(
       property_details->'steps'->'res_rent_location'->>'city',
       property_details->'steps'->'res_sale_location'->>'city',
       property_details->'steps'->'res_flat_location'->>'city',
       property_details->'steps'->'res_pg_location'->>'city',
       property_details->'location'->>'city'
   );
END;


Schema: public | Name: extract_residential_state | Type: FUNCTION
  Returns: text | Specific Name: extract_residential_state_198630
  Definition: 
BEGIN
   RETURN COALESCE(
       property_details->'steps'->'res_rent_location'->>'state',
       property_details->'steps'->'res_sale_location'->>'state',
       property_details->'steps'->'res_flat_location'->>'state',
       property_details->'steps'->'res_pg_location'->>'state',
       property_details->'location'->>'state'
   );
END;


